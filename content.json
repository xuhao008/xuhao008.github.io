{"meta":{"title":"JAVA入土","subtitle":"学习使我快乐","description":"技术博客,Java,记录美好学习时光","author":"晨月","url":"http://xuhao008.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-24T22:39:46.000Z","updated":"2020-08-05T03:27:43.142Z","comments":false,"path":"categories/index.html","permalink":"http://xuhao008.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-24T22:31:06.000Z","updated":"2020-08-05T03:27:43.157Z","comments":false,"path":"tags/index.html","permalink":"http://xuhao008.github.io/tags/index.html","excerpt":"","text":""},{"title":"hot","date":"2020-04-25T12:16:51.000Z","updated":"2020-08-05T03:27:43.157Z","comments":true,"path":"hot/index.html","permalink":"http://xuhao008.github.io/hot/index.html","excerpt":"","text":"AV.initialize(\"wG3LQ9piimb7LMXEDw0BCOmG-gzGzoHsz\", \"pXkLtQymiNmeMV5F3bNJ2VKy\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"}],"posts":[{"title":"第七天","slug":"第七天","date":"2020-08-06T16:05:12.000Z","updated":"2020-08-06T09:34:14.063Z","comments":true,"path":"2020/08/07/第七天/","link":"","permalink":"http://xuhao008.github.io/2020/08/07/%E7%AC%AC%E4%B8%83%E5%A4%A9/","excerpt":"uniapp学习 1、什么是uniapp uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。 2、uniap学习 开发工具 首先需要下载HbuilderX开发工具，它是通用的前端开发工具，但为uni-app做了特别强化。 我们可以通过该工具直接创建uniapp项目，并且选择各种方式运行。 项目目录结构 pages.json文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等 manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。 App.vue是我们的跟组件，所有页面都是在App.vue下进行切换的，是页面入口文件，可以调用应用的生命周期函数。 main.js是我们的项目入口文件，主要作用是初始化vue实例并使用需要的插件。 uni.scss文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置。 unpackage 就是打包目录，在这里有各个平台的打包文件 pages所有的页面存放目录 static静态资源目录，例如图片等 components 组件存放目录 3、page 通过pages来配置页面 pages数组数组中第一项表示应用启动页 1234567891011\"pages\": [ 、 &#123; \"path\":\"pages/message/message\" &#125;, &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationBarTitleText\": \"uni-app\" &#125; &#125; ]","text":"uniapp学习 1、什么是uniapp uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。 2、uniap学习 开发工具 首先需要下载HbuilderX开发工具，它是通用的前端开发工具，但为uni-app做了特别强化。 我们可以通过该工具直接创建uniapp项目，并且选择各种方式运行。 项目目录结构 pages.json文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等 manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。 App.vue是我们的跟组件，所有页面都是在App.vue下进行切换的，是页面入口文件，可以调用应用的生命周期函数。 main.js是我们的项目入口文件，主要作用是初始化vue实例并使用需要的插件。 uni.scss文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置。 unpackage 就是打包目录，在这里有各个平台的打包文件 pages所有的页面存放目录 static静态资源目录，例如图片等 components 组件存放目录 3、page 通过pages来配置页面 pages数组数组中第一项表示应用启动页 1234567891011\"pages\": [ 、 &#123; \"path\":\"pages/message/message\" &#125;, &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationBarTitleText\": \"uni-app\" &#125; &#125; ] 4、tabbar 如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页。 Tips 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 12345678910111213141516171819202122\"tabBar\": &#123; \"list\": [ &#123; \"text\": \"首页\", \"pagePath\":\"pages/index/index\", \"iconPath\":\"static/tabs/home.png\", \"selectedIconPath\":\"static/tabs/home-active.png\" &#125;, &#123; \"text\": \"信息\", \"pagePath\":\"pages/message/message\", \"iconPath\":\"static/tabs/message.png\", \"selectedIconPath\":\"static/tabs/message-active.png\" &#125;, &#123; \"text\": \"我们\", \"pagePath\":\"pages/contact/contact\", \"iconPath\":\"static/tabs/contact.png\", \"selectedIconPath\":\"static/tabs/contact-active.png\" &#125; ] &#125; 5、uni-app中的数据绑定 在页面中需要定义数据，和我们之前的vue一摸一样，直接在data中定义数据即可 1234567export default &#123; data () &#123; return &#123; msg: 'hello-uni' &#125; &#125;&#125; 插值表达式的使用 利用插值表达式渲染基本数据 1&lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt; 在插值表达式中使用三元运算 1&lt;view&gt;&#123;&#123; flag ? '我是真的':'我是假的' &#125;&#125;&lt;/view&gt; 基本运算 1&lt;view&gt;&#123;&#123;1+1&#125;&#125;&lt;/view&gt; v-for的使用 123456789101112&lt;view v-for=\"(item,i) in arr\" :key=\"i\"&gt;名字：&#123;&#123;item.name&#125;&#125;---年龄：&#123;&#123;item.age&#125;&#125;&lt;/view&gt;data () &#123; return &#123; arr: [ &#123; name: '刘能', age: 29 &#125;, &#123; name: '赵四', age: 39 &#125;, &#123; name: '宋小宝', age: 49 &#125;, &#123; name: '小沈阳', age: 59 &#125; ] &#125;&#125; 6、uni的生命周期 应用的生命周期 生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。 生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数 uni-app 支持如下应用生命周期函数： 函数名 说明 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onError 当 uni-app 报错时触发 页面的生命周期 uni-app 支持如下页面生命周期函数： 函数名 说明 平台差异说明 最低版本 onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考示例 onShow 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 onReady 监听页面初次渲染完成。 onHide 监听页面隐藏 onUnload 监听页面卸载 7、下拉刷新 开启下拉刷新 在uni-app中有两种方式开启下拉刷新 需要在 pages.json 里，找到的当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh 通过调用uni.startPullDownRefresh方法来开启下拉刷新 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"startPull\"&gt;开启下拉刷新&lt;/button&gt; 杭州学科 &lt;view v-for=\"(item,index) in arr\" :key=\"index\"&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; arr: ['前端','java','ui','大数据'] &#125; &#125;, methods: &#123; startPull () &#123; uni.startPullDownRefresh() &#125; &#125;, onPullDownRefresh () &#123; this.arr = [] setTimeout(()=&gt; &#123; this.arr = ['前端','java','ui','大数据'] uni.stopPullDownRefresh() &#125;, 1000); &#125; &#125;&lt;/script&gt; 8、网络请求 在uni中可以调用uni.request方法进行请求网络请求 需要注意的是：在小程序中网络相关的 API 在使用前需要配置域名白名单。 123456789101112131415161718192021&lt;template&gt; &lt;view&gt; &lt;button @click=\"sendGet\"&gt;发送请求&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; sendGet () &#123; uni.request(&#123; url: 'http://localhost:8082/api/getlunbo', method: 'GET', header:&#123; 'Content-type':'application/x-www-form-urlencoded'&#125;, success:res=&gt;&#123; console.log(res) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 9、数据缓存 uni.setStorage 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"setStor\"&gt;存储数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; setStor () &#123; uni.setStorage(&#123; key: 'id', data: 100, success () &#123; console.log('存储成功') &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; uni.setStorageSync 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"setStor\"&gt;存储数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; setStor () &#123; uni.setStorage(&#123; key: 'id', data: 100, success () &#123; console.log('存储成功') &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; uni.getStorage 从本地缓存中异步获取指定 key 对应的内容。 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"getStorage\"&gt;获取数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; id: '' &#125; &#125;, methods: &#123; getStorage () &#123; uni.getStorage(&#123; key: 'id', success: res=&gt;&#123; this.id = res.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; uni.getStorageSync 从本地缓存中同步获取指定 key 对应的内容。 123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"getStorage\"&gt;获取数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; getStorage () &#123; const id = uni.getStorageSync('id') console.log(id) &#125; &#125; &#125;&lt;/script&gt;``` **uni.removeStorage** 从本地缓存中异步移除指定 key。 删除数据 export default { methods: { removeStorage () { uni.removeStorage({ key: 'id', success: function () { console.log('删除成功') } }) } } } 12**uni.removeStorageSync** 从本地缓存中同步移除指定 key。 删除数据 export default { methods: { removeStorage () { uni.removeStorageSync('id') } } } 12345#### 10、上传图片、预览图片##### 上传图片uni.chooseImage方法从本地相册选择图片或使用相机拍照。 上传图片 export default { data () { return { imgArr: [] } }, methods: { chooseImg () { uni.chooseImage({ count: 9, success: res=>{ this.imgArr = res.tempFilePaths } }) } } } 12**预览图片** previewImg (current) { uni.previewImage({ urls: this.imgArr, current }) } 12345678910111213141516171819#### 11、条件注释实现跨段兼容条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。**写法:** 以 #ifdef 加平台标识 开头，以 #endif 结尾。平台标识| 值 | 平台 | 参考文档 || ---------- | ------------------------------------------------------ | ------------------------------------------------------------ || APP-PLUS | 5+App | [HTML5+ 规范](http://www.html5plus.org/doc/) || H5 | H5 | || MP-WEIXIN | 微信小程序 | [微信小程序](https://developers.weixin.qq.com/miniprogram/dev/api/) || MP-ALIPAY | 支付宝小程序 | [支付宝小程序](https://docs.alipay.com/mini/developer/getting-started) || MP-BAIDU | 百度小程序 | [百度小程序](https://smartprogram.baidu.com/docs/develop/tutorial/codedir/) || MP-TOUTIAO | 头条小程序 | [头条小程序](https://developer.toutiao.com/dev/cn/mini-app/develop/framework/basic-reference/introduction) || MP-QQ | QQ小程序 | （目前仅cli版支持） || MP | 微信小程序/支付宝小程序/百度小程序/头条小程序/QQ小程序 | |**组件的条件注释** h5页面会显示 微信小程序会显示 app会显示 1**api的条件注释** onLoad () { //#ifdef MP-WEIXIN console.log('微信小程序') //#endif //#ifdef H5 console.log('h5页面') //#endif } 1**样式的条件注释** /* #ifdef H5 */ view{ height: 100px; line-height: 100px; background: red; } /* #endif */ /* #ifdef MP-WEIXIN */ view{ height: 100px; line-height: 100px; background: green; } /* #endif */ 12345#### 11、uni中的导航跳转利用**navigator**进行跳转navigator详细文档：[文档地址](https://uniapp.dcloud.io/component/navigator)跳转到普通页面 跳转到关于页面 1跳转到tabbar页面 跳转到message页面 123456789##### 利用编程式导航进行跳转[导航跳转文档]( [uni.navigateTo](https://uniapp.dcloud.io/api/router?id=navigateto))**利用navigateTo进行导航跳转**保留当前页面，跳转到应用内的某个页面，使用`uni.navigateBack`可以返回到原页面。```html&lt;button type=\"primary\" @click=\"goAbout\"&gt;跳转到关于页面&lt;/button&gt; 通过navigateTo方法进行跳转到普通页面 12345goAbout () &#123; uni.navigateTo(&#123; url: '/pages/about/about', &#125;)&#125; 通过switchTab跳转到tabbar页面 跳转到tabbar页面 1&lt;button type=\"primary\" @click=\"goMessage\"&gt;跳转到message页面&lt;/button&gt; 通过switchTab方法进行跳转 12345goMessage () &#123; uni.switchTab(&#123; url: '/pages/message/message' &#125;)&#125; redirectTo进行跳转 关闭当前页面，跳转到应用内的某个页面。 12345678&lt;!-- template --&gt;&lt;button type=\"primary\" @click=\"goMessage\"&gt;跳转到message页面&lt;/button&gt;&lt;!-- js --&gt;goMessage () &#123; uni.switchTab(&#123; url: '/pages/message/message' &#125;)&#125; 通过onUnload测试当前组件确实卸载 123onUnload () &#123; console.log('组件卸载了')&#125; 导航跳转传递参数 在导航进行跳转到下一个页面的同时，可以给下一个页面传递相应的参数，接收参数的页面可以通过onLoad生命周期进行接收 传递参数的页面 12345goAbout () &#123; uni.navigateTo(&#123; url: '/pages/about/about?id=80', &#125;);&#125; 接收参数的页面 1234567&lt;script&gt; export default &#123; onLoad (options) &#123; console.log(options) &#125; &#125;&lt;/script&gt; 12、uni-app中组件的创建 在uni-app中，可以通过创建一个后缀名为vue的文件，即创建一个组件成功，其他组件可以将该组件通过impot的方式导入，在通过components进行注册即可 创建login组件，在component中创建login目录，然后新建login.vue文件 1234567891011&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在其他组件中导入该组件并注册 1import login from \"@/components/test/test.vue\" 注册组件 1components: &#123;test&#125; 使用组件 1&lt;test&gt;&lt;/test&gt; 组件的生命周期函数 beforeCreate 在实例初始化之后被调用。详见 created 在实例创建完成后被立即调用。详见 beforeMount 在挂载开始之前被调用。详见 mounted 挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档 beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。详见 仅H5平台支持 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。详见 仅H5平台支持 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。详见 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。详见 组件的通讯 父组件给子组件传值 通过props来接受外界传递到组件内部的值 1234567891011121314&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &#123;&#123;msg&#125;&#125; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: ['msg'] &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 其他组件在使用login组件的时候传递值 123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;test :msg=\"msg\"&gt;&lt;/test&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import test from \"@/components/test/test.vue\" export default &#123; data () &#123; return &#123; msg: 'hello' &#125; &#125;, components: &#123;test&#125; &#125;&lt;/script&gt; 子组件给父组件传值 通过$emit触发事件进行传递参数 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &#123;&#123;msg&#125;&#125; &lt;button type=\"primary\" @click=\"sendMsg\"&gt;给父组件传值&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; status: '打篮球' &#125; &#125;, props: &#123; msg: &#123; type: String, value: '' &#125; &#125;, methods: &#123; sendMsg () &#123; this.$emit('myEvent',this.status) &#125; &#125; &#125;&lt;/script&gt; 父组件定义自定义事件并接收参数 12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;test :msg=\"msg\" @myEvent=\"getMsg\"&gt;&lt;/test&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import test from \"@/components/test/test.vue\" export default &#123; data () &#123; return &#123; msg: 'hello' &#125; &#125;, methods: &#123; getMsg (res) &#123; console.log(res) &#125; &#125;, components: &#123;test&#125; &#125;&lt;/script&gt; 兄弟组件通讯 uni-ui的使用 uni-ui文档 1、进入Grid宫格组件 2、使用HBuilderX导入该组件 3、导入该组件 12import uniGrid from \"@/components/uni-grid/uni-grid.vue\"import uniGridItem from \"@/components/uni-grid-item/uni-grid-item.vue\" 4、注册组件 1components: &#123;uniGrid,uniGridItem&#125; 5、使用组件 1234567891011&lt;uni-grid :column=\"3\"&gt; &lt;uni-grid-item&gt; &lt;text class=\"text\"&gt;文本&lt;/text&gt; &lt;/uni-grid-item&gt; &lt;uni-grid-item&gt; &lt;text class=\"text\"&gt;文本&lt;/text&gt; &lt;/uni-grid-item&gt; &lt;uni-grid-item&gt; &lt;text class=\"text\"&gt;文本&lt;/text&gt; &lt;/uni-grid-item&gt;&lt;/uni-grid&gt;","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第六天","slug":"第六天","date":"2020-08-05T16:05:12.000Z","updated":"2020-08-06T09:34:50.562Z","comments":true,"path":"2020/08/06/第六天/","link":"","permalink":"http://xuhao008.github.io/2020/08/06/%E7%AC%AC%E5%85%AD%E5%A4%A9/","excerpt":"重新了解了git相关命令，但是还是需要重新系统的学习和应用 使用hexo重新部署了自己的个人博客，更新了博客","text":"重新了解了git相关命令，但是还是需要重新系统的学习和应用 使用hexo重新部署了自己的个人博客，更新了博客","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-05T03:27:43.110Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2020/08/05/hello-world/","link":"","permalink":"http://xuhao008.github.io/2020/08/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"第五天","slug":"第五天","date":"2020-08-04T18:05:12.000Z","updated":"2020-08-05T06:23:12.616Z","comments":true,"path":"2020/08/05/第五天/","link":"","permalink":"http://xuhao008.github.io/2020/08/05/%E7%AC%AC%E4%BA%94%E5%A4%A9/","excerpt":"vue.js 1、vue项目目录结构 通过weboack模板安装后的目录 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号等。我们初学可以使用默认的。 static 静态资源目录，如图片、字体等。 test 初始测试目录，可删除 .xxx文件 这些是一些配置文件，包括语法配置，git配置等。 index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。 package.json 项目配置文件。 README.md 项目的说明文档，markdown 格式 src目录 目录/文件 说明 assets 放置一些图片，如logo等。 components 目录里面放了一个组件文件，可以不用。 router 项目的路由，通过下面的index.js可以设置路由 App.vue 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。 main.js 项目的核心文件。 2、watch监听事件 我们可以通过 watch 来响应数据的变化。 例如： 123456789101112 &lt;p style = \"font-size:25px;\"&gt;计数器: &#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;button @click = \"counter++\" style = \"font-size:25px;\"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = \"text/javascript\"&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1 &#125;&#125;);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!'); 3、组件","text":"vue.js 1、vue项目目录结构 通过weboack模板安装后的目录 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号等。我们初学可以使用默认的。 static 静态资源目录，如图片、字体等。 test 初始测试目录，可删除 .xxx文件 这些是一些配置文件，包括语法配置，git配置等。 index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。 package.json 项目配置文件。 README.md 项目的说明文档，markdown 格式 src目录 目录/文件 说明 assets 放置一些图片，如logo等。 components 目录里面放了一个组件文件，可以不用。 router 项目的路由，通过下面的index.js可以设置路由 App.vue 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。 main.js 项目的核心文件。 2、watch监听事件 我们可以通过 watch 来响应数据的变化。 例如： 123456789101112 &lt;p style = \"font-size:25px;\"&gt;计数器: &#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;button @click = \"counter++\" style = \"font-size:25px;\"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = \"text/javascript\"&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1 &#125;&#125;);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!'); 3、组件 组件可以扩展 HTML 元素，封装可重用的代码。 组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树 注册一个全局组件语法格式如下： 1Vue.component(tagName, options) tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件： 1&lt;tagName&gt;&lt;/tagName&gt; 全局组件 所有实例都能用全局组件。 1234567891011121314&lt;div id=\"app\"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('runoob', &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 局部组件 我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;var Child = &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125; // 创建根实例new Vue(&#123; el: '#app', components: &#123; // &lt;runoob&gt; 将只在父模板可用 'runoob': Child &#125;&#125;)&lt;/script&gt; Prop prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。 父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 “prop”： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;child message=\"hello!\"&gt;&lt;/child&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 \"this.message\" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 动态 Prop 类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件： 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:message=\"parentMsg\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 \"this.message\" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data: &#123; parentMsg: '父组件内容' &#125;&#125;)&lt;/script&gt; 以下实例中使用 v-bind 指令将 todo 传到每一个重复的组件中： 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;todo-item v-for=\"item in sites\" v-bind:todo=\"item\"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; text: 'Runoob' &#125;, &#123; text: 'Google' &#125;, &#123; text: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; 注意: prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。 Prop 验证 组件可以为 props 指定验证要求。 为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如： 123456789101112131415161718192021222324252627282930313233Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 自定义事件 父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件！ 我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 以下实例中子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementHandler\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementHandler: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; 如果你想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如： 1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; 上面例子中，可以看到 button-counter 组件中的 data 不是一个对象，而是一个函数，这样的好处就是每个实例可以维护一份被返回对象的独立的拷贝，如果 data 是一个对象则会影响到其他实例 4、自定义指令 Vue 也允许注册自定义指令 下面我们注册一个全局指令 v-focus, 该指令的功能是在页面加载时，元素获得焦点： 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt;&lt;/div&gt; &lt;script&gt;// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 钩子函数 指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 钩子函数参数 钩子函数的参数有： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=“1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的表达式或变量名。 例如 v-my-directive=“1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 1234567891011121314151617181920212223&lt;div id=\"app\" v-runoob:hello.a.b=\"message\"&gt;&lt;/div&gt; &lt;script&gt;Vue.directive('runoob', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#app', data: &#123; message: '菜鸟教程!' &#125;&#125;)&lt;/script&gt; 结果 123456name: \"runoob\"value: \"菜鸟教程!\"expression: \"message\"argument: \"hello\"modifiers: &#123;\"a\":true,\"b\":true&#125;vnode keys: tag, data, children, text, elm, ns, context, functionalContext, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce 有时候我们不需要其他钩子函数，我们可以简写函数，如下格式： 1234Vue.directive('runoob', function (el, binding) &#123; // 设置指令的背景颜色 el.style.backgroundColor = binding.value.color&#125;) 指令函数可接受所有合法的 JavaScript 表达式，以下实例传入了 JavaScript 对象： 1234567891011121314&lt;div id=\"app\"&gt; &lt;div v-runoob=\"&#123; color: 'green', text: '菜鸟教程!' &#125;\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.directive('runoob', function (el, binding) &#123; // 简写方式设置文本及背景颜色 el.innerHTML = binding.value.text el.style.backgroundColor = binding.value.color&#125;)new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 5、路由 通过路由可以根据不同路径访问不同内容，可以实现多视图的单页web应用 使用vue路由需要安装依赖：npm install vue-router 在第四天也学习过相关路由，今天继续完善相关代码的解释 123456789101112&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/index\"&gt;首页&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 相关属性 to 表示目标路由的链接。 当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to=\"home\"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=\"home\"&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=\"'home'\"&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=\"'home'\"&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=\"&#123; path: 'home' &#125;\"&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"&gt;Register&lt;/router-link&gt; replace 设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录。 1&lt;router-link :to=\"&#123; path: '/abc'&#125;\" replace&gt;&lt;/router-link&gt; append 设置 append 属性后，则在当前 (相对) 路径前添加其路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b 1&lt;router-link :to=\"&#123; path: 'relative/path'&#125;\" append&gt;&lt;/router-link&gt; tag 有时候想要 渲染成某种标签，例如 。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。 123&lt;router-link to=\"/foo\" tag=\"li\"&gt;foo&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;li&gt;foo&lt;/li&gt; active-class 设置 链接激活时使用的 CSS 类名。可以通过以下代码来替代。 123456789&lt;style&gt; ._active&#123; background-color : red; &#125;&lt;/style&gt;&lt;p&gt; &lt;router-link v-bind:to = \"&#123; path: '/route1'&#125;\" active-class = \"_active\"&gt;Router Link 1&lt;/router-link&gt; &lt;router-link v-bind:to = \"&#123; path: '/route2'&#125;\" tag = \"span\"&gt;Router Link 2&lt;/router-link&gt;&lt;/p&gt; exact-active-class 配置当链接被精确匹配的时候应该激活的 class。可以通过以下代码来替代。 1234&lt;p&gt; &lt;router-link v-bind:to = \"&#123; path: '/route1'&#125;\" exact-active-class = \"_active\"&gt;Router Link 1&lt;/router-link&gt; &lt;router-link v-bind:to = \"&#123; path: '/route2'&#125;\" tag = \"span\"&gt;Router Link 2&lt;/router-link&gt;&lt;/p&gt; event 声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。 1&lt;router-link v-bind:to = \"&#123; path: '/route1'&#125;\" event = \"mouseover\"&gt;Router Link 1&lt;/router-link&gt; 以上代码设置了 event 为 mouseover ，及在鼠标移动到 Router Link 1 上时导航的 HTML 内容会发生改变。 exact-active-class 和 active-class 的区别 router-link 默认情况下的路由是模糊匹配，例如当前路径是 /article/1 那么也会激活 ，所以当设置 exact-active-class 以后，这个 router-link 只有在当前路由被全包含匹配时才会被激活 exact-active-class 中的 class，例如： 1&lt;router-link to=\"/article\" active-class=\"router-active\"&gt;&lt;/router-link&gt; 当用户访问 /article/1 时会被激活为： 1&lt;a href=\"#/article\" class=\"router-active\" rel=\"nofollow\"&gt;&lt;/a&gt; 而当使用： 1&lt;router-link to=\"/article\" exact-active-class=\"router-active\"&gt;&lt;/router-link&gt; 当用户访问 /article/1 时，不会激活这个 link 的 class： 1&lt;a href=\"#/article\" rel=\"nofollow\"&gt;&lt;/a&gt;","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第四天","slug":"第四天","date":"2020-08-03T13:05:12.000Z","updated":"2020-08-05T06:13:34.658Z","comments":true,"path":"2020/08/03/第四天/","link":"","permalink":"http://xuhao008.github.io/2020/08/03/%E7%AC%AC%E5%9B%9B%E5%A4%A9/","excerpt":"Vue.js 1、Vue.js 是什么 vue是一套用于构建用户界面的渐进式框架 可以通过引入vue.js，进行vue项目框架开发 1234&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 2、声明式渲染 Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统： 12345678910&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 #app) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。 v-bind：该指令的意思是：“将这个元素节点的 title attribute 和 Vue 实例的 message property 保持一致”。","text":"Vue.js 1、Vue.js 是什么 vue是一套用于构建用户界面的渐进式框架 可以通过引入vue.js，进行vue项目框架开发 1234&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 2、声明式渲染 Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统： 12345678910&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 #app) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。 v-bind：该指令的意思是：“将这个元素节点的 title attribute 和 Vue 实例的 message property 保持一致”。 v-bind 缩写 12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=\"url\"&gt; ... &lt;/a&gt; 3、条件与循环 **v-for **指令可以绑定数组的数据来渲染一个项目列表： 4、处理用户输入 为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法 v-on 缩写 12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=\"doSomething\"&gt; ... &lt;/a&gt; v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定 5、组件化应用构建 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例 1234567891011121314151617181920212223242526272829303132&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;!-- 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的。 我们也需要为每个组件提供一个“key”，稍后再 作详细解释。 --&gt; &lt;todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\" &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; id: 0, text: '蔬菜' &#125;, &#123; id: 1, text: '奶酪' &#125;, &#123; id: 2, text: '随便其它什么人吃的东西' &#125; ] &#125;&#125;) 6、vue生命周期 创建vue项目 需要先安装nodejs，vue-cli 使用vue create projectname创建 或者通过webpack模板安装：vue init webpack projectname 可以在package.json中配置启动命令 12345\"scripts\": &#123; \"dev\": \"vue-cli-service serve\", \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\"&#125; npm run serve,npm run dev,npm run build 在App.vue中可以设置跳转路由和显示页面 12345678&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-link active-class=\"active\" exact :to=\"&#123;name: 'Home',params:&#123;classification:'Home'&#125;&#125;\"&gt;首页&lt;/router-link&gt; &lt;router-link active-class=\"active\" exact :to=\"&#123;name: 'Page',params:&#123;classification:'Page'&#125;&#125;\"&gt;页面&lt;/router-link&gt; &lt;!--支持路由页面显示--&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 设置跳转路由 12345678910111213141516171819202122232425const routes: Array&lt;RouteConfig&gt; = [&#123; path: '/item/:classification(.*)', name: 'Home', component: Home, meta: &#123; title: '主页' &#125; &#125;] const router = new VueRouter(&#123; //hash模式，兼容性较高，地址栏多了一个#号，history模式较美观 mode: 'history', base: process.env.BASE_URL, routes&#125;)//注册一个全局前置守卫，同步浏览器标签名称router.beforeEach((to,form,next) =&gt;&#123; /*路由变化修改title*/ if(to.meta.title)&#123; document.title=to.meta.title &#125; next();&#125;) 如果有进行后台请求，我们可以使用axios，先在终端安装:npm i axios 然后在需要的页面导入：import axios from ‘axios’ 如果前后端不在一个服务器，就要跨域，我们可以通过设置代理配置，进行跨域 在项目根目录下创建vue.config.js 123456789101112module.exports=&#123; devServer:&#123; proxy:&#123; 'api':&#123; target: 'http://localhost:8000', pathRewrite: &#123; '^/api' : '' &#125; &#125; &#125; &#125;&#125; 这里的pathRewrite，代表忽略请求路径的/api，target代表要代理的域名地址 使用： 123let re=await axios(&#123; url: 'api/page/getGoodList' &#125;);","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第三天","slug":"第三天","date":"2020-07-31T08:05:12.000Z","updated":"2020-08-05T05:23:53.023Z","comments":true,"path":"2020/07/31/第三天/","link":"","permalink":"http://xuhao008.github.io/2020/07/31/%E7%AC%AC%E4%B8%89%E5%A4%A9/","excerpt":"一、JAVA基础知识点 1、关于java,final,static,this,super关键词的总结 https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super 2、使用 this 和 super 要注意的问题 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 3、static 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问 静态导包 123456789101112 //将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用 //如果只想导入单一某个静态方法，只需要将换成对应的方法名即可import static java.lang.Math.*;//换成import static java.lang.Math.max;具有一样的效果public class Demo &#123; public static void main(String[] args) &#123; int max = max(1,2); System.out.println(max); &#125;&#125; 4、接口和抽象类","text":"一、JAVA基础知识点 1、关于java,final,static,this,super关键词的总结 https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super 2、使用 this 和 super 要注意的问题 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 3、static 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问 静态导包 123456789101112 //将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用 //如果只想导入单一某个静态方法，只需要将换成对应的方法名即可import static java.lang.Math.*;//换成import static java.lang.Math.max;具有一样的效果public class Demo &#123; public static void main(String[] args) &#123; int max = max(1,2); System.out.println(max); &#125;&#125; 4、接口和抽象类 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 关于抽象类 JDK 1.8以前，抽象类的方法替代访问权限为受保护的 JDK 1.8时，抽象类的方法可以访问权限转换为默认 关于接口 JDK 1.8以前，接口中的方法必须是public的 JDK 1.8时，接口中的方法可以是public的，也可以是默认的 JDK 1.9时，接口中的方法可以是private的 5、collections 工具类和 Arrays 工具类常见方法总结 https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md 二、JAVA易错问题 1、正确使用 equals 方法 Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 1234567// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常String str = null;if (str.equals(\"SnailClimb\")) &#123; ...&#125; else &#123; ..&#125; 运行上面的程序会抛出空指针异常，下面这种就不会 1\"SnailClimb\".equals(str);// false 不过更推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。 1Objects.equals(null,\"SnailClimb\");// false 我们看一下java.util.Objects#equals的源码 1234public static boolean equals(Object a, Object b) &#123; // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。 return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 2、合理使用BigDecimal 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。看下面代码： 12345float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;System.out.println(a);// 0.100000024System.out.println(b);// 0.099999964System.out.println(a == b);// false 结果和我们需要的不同，因为这样子会精度丢失，我们可以使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。 1234567891011121314BigDecimal a = new BigDecimal(\"1.0\");BigDecimal b = new BigDecimal(\"0.9\");BigDecimal c = new BigDecimal(\"0.8\");BigDecimal x = a.subtract(b);// 0.1BigDecimal y = b.subtract(c);// 0.1System.out.println(x.equals(y));// true//a.compareTo(b);返回 -1 表示小于，0 表示 等于， 1表示 大于。BigDecimal a = new BigDecimal(\"1.0\");BigDecimal b = new BigDecimal(\"0.9\");System.out.println(a.compareTo(b));// 1//通过 setScale方法设置保留几位小数以及保留规则BigDecimal m = new BigDecimal(\"1.255433\");BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);System.out.println(n);// 1.255 3、Arrays.asList() Arrays.asList()可以使用它将一个数组转换为一个List集合。 Arrays.asList()将数组转换为集合后,底层其实还是数组 在使用时要注意，传递的数组必须是对象数组，而不是基本类型。 Arrays.asList()是泛型方法，传入的对象必须是对象数组。 1234567int[] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//1System.out.println(myList.get(0));//数组地址值System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsExceptionint [] array=(int[]) myList.get(0);System.out.println(array[0]);//1 我们使用包装类型数组就可以解决这个问题。 1Integer[] myArray = &#123; 1, 2, 3 &#125;; 使用集合的修改方法:add()、remove()、clear()会抛出异常。 1234List myList = Arrays.asList(1, 2, 3);myList.add(4);//运行时报错：UnsupportedOperationExceptionmyList.remove(1);//运行时报错：UnsupportedOperationExceptionmyList.clear();//运行时报错：UnsupportedOperationException 其他将数组转换为集合的方法 1List list = new ArrayList&lt;&gt;(Arrays.asList(\"a\", \"b\", \"c\")) 使用stream 12345Integer [] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); 三、J2EE基础 1、Servlet 在Java Web程序中，Servlet主要负责接收用户请求 HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法**。**Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），一个Servlet可以设置多个URL访问。Servlet不是线程安全，因此要谨慎使用类变量。 1、Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： 12345void init(ServletConfig config) throws ServletExceptionvoid service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOExceptionvoid destroy()java.lang.String getServletInfo()ServletConfig getServletConfig() 2、生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。 3、什么情况下调用doGet()和doPost() Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。 4、转发(Forward)和重定向(Redirect)的区别 转发是服务器行为，重定向是客户端行为 。 转发（Forward） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。 1request.getRequestDispatcher(\"login_success.jsp\").forward(request, response); 重定向（Redirect） 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。 从地址栏显示来说: forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说: forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据. 从运用地方来说: forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说: forward:高. redirect:低. 5、自动刷新(Refresh) 自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如： 1Response.setHeader(\"Refresh\",\"5;URL=http://localhost:8080/servlet/example.htm\"); 其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次） 6、JSP9大内置对象 request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 四、重点知识点 1、枚举的使用 https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basic/用好Java中的枚举真的没有那么简单.md","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第二天","slug":"第二天","date":"2020-07-30T15:05:12.000Z","updated":"2020-08-05T05:23:41.334Z","comments":true,"path":"2020/07/30/第二天/","link":"","permalink":"http://xuhao008.github.io/2020/07/30/%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"JAVA基础学习 1、java语言特点 面向对象—&gt;继承，封装，多态 可以跨平台—&gt;java虚拟机(JVM) 安全性，可靠性 编译与解释并存 2、JDK，JRE，JVM特点区别 JDK和JRE JDK包括JRE，有编译器和一系列工具，可以创建和编译程序 JRE是java的运行环境，包括了java虚拟机JVM，java类库，和一些组件 在很多情况下，如果只是要运行java程序，可以只安装JRE，如果需要编程就需要JDK了，但是如果代码里面有JSP就需要JDK了，因为JSP在运行的时候会先把代码转换成servlet，通过JDK编译 JVM，JAVA虚拟机，用来运行java字节码，JVM具有不同实现，可以在多个平台运行 在java中，可以被jvm所理解的代码就是字节码，也就是.class结尾的文件。 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 3、JAVA程序的主类 包含main()方法的类，就是主类，而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 4、字符型常量和字符串常量的区别?","text":"JAVA基础学习 1、java语言特点 面向对象—&gt;继承，封装，多态 可以跨平台—&gt;java虚拟机(JVM) 安全性，可靠性 编译与解释并存 2、JDK，JRE，JVM特点区别 JDK和JRE JDK包括JRE，有编译器和一系列工具，可以创建和编译程序 JRE是java的运行环境，包括了java虚拟机JVM，java类库，和一些组件 在很多情况下，如果只是要运行java程序，可以只安装JRE，如果需要编程就需要JDK了，但是如果代码里面有JSP就需要JDK了，因为JSP在运行的时候会先把代码转换成servlet，通过JDK编译 JVM，JAVA虚拟机，用来运行java字节码，JVM具有不同实现，可以在多个平台运行 在java中，可以被jvm所理解的代码就是字节码，也就是.class结尾的文件。 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 3、JAVA程序的主类 包含main()方法的类，就是主类，而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 4、字符型常量和字符串常量的区别? 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节) 5、自增自减运算符 在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。 ++和–运算符可以放在操作数之前，也可以放在操作数之后，当运算符放在操作数之前时，先自增/减，再赋值；当运算符放在操作数之后时，先赋值，再自增/减。 用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。 6、continue、break、和return的区别 continue ：指跳出当前的这一次循环，继续下一次循环。 break ：指跳出整个循环体，继续执行循环下面的语句。 return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法： return;：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value; ：return 一个特定值，用于有返回值函数的方法 7、Java泛型，什么是类型擦除，常用的通配符 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 1234567891011List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(12);//这里直接添加会报错list.add(\"a\");Class&lt;? extends List&gt; clazz = list.getClass();Method add = clazz.getDeclaredMethod(\"add\", Object.class);//但是通过反射添加，是可以的add.invoke(list, \"kl\");System.out.println(list) 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。 1.泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 如何实例化泛型类： 1Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); 2.泛型接口 ： 123public interface Generator&lt;T&gt; &#123; public T method();&#125; 实现泛型接口，不指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T method() &#123; return null; &#125;&#125; 实现泛型接口，指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123; @Override public String method() &#123; return \"hello\"; &#125;&#125; 3.泛型方法 ： 1234567public static &lt; E &gt; void printArray( E[] inputArray ) &#123; for ( E element : inputArray )&#123; System.out.printf( \"%s \", element ); &#125; System.out.println(); &#125; 使用： 12345// 创建不同类型数组： Integer, Double 和 CharacterInteger[] intArray = &#123; 1, 2, 3 &#125;;String[] stringArray = &#123; \"Hello\", \"World\" &#125;;printArray( intArray ); printArray( stringArray ); 常用的通配符为： T，E，K，V，？ ？ 表示不确定的 java 类型 T (type) 表示具体的一个java类型 K V (key value) 分别代表java键值中的Key Value E (element) 代表Element 8、hashCode()与 equals() hashCode()介绍: hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 为什么要有 hashCode？ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 为什么重写 equals 时必须重写 hashCode 方法？ 如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） Java 面向对象 1、面向对象和面向过程的区别 1、面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 2、面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第一天","slug":"第一天","date":"2020-07-29T15:05:12.000Z","updated":"2020-08-05T05:24:23.377Z","comments":true,"path":"2020/07/29/第一天/","link":"","permalink":"http://xuhao008.github.io/2020/07/29/%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"java的概念 Java是一种可以撰写跨平台应用程序的、面向对象的程序设计语言。简单说，Java就是一种语言，不过是一种针对jvm的语言，Java编译后是字节码，而jvm会把这些字节码解释成机器码，然后做出相应的动作。 而Java是一种特殊的解释型语言（首先将java的类文件编译成jvm能识别的字节码文件，然后针对热点方法，利用JTT即时编译技术，编译执行，而对于非热点方法，采用的则是解释执行） java主要分三块，j2se：java的基础核心语言。j2me：java的微型模块，专门针对内存小，没有持续电源等小型设备。j2ee：java的企业模块，专门针对企业数据库服务器的连接维护。 手机用到的是用j2me所编出来的小程序 javac：Java编译器 java：Java解释器 jdb：Java调试器 javap：反编译 javadoc：文档生成器","text":"java的概念 Java是一种可以撰写跨平台应用程序的、面向对象的程序设计语言。简单说，Java就是一种语言，不过是一种针对jvm的语言，Java编译后是字节码，而jvm会把这些字节码解释成机器码，然后做出相应的动作。 而Java是一种特殊的解释型语言（首先将java的类文件编译成jvm能识别的字节码文件，然后针对热点方法，利用JTT即时编译技术，编译执行，而对于非热点方法，采用的则是解释执行） java主要分三块，j2se：java的基础核心语言。j2me：java的微型模块，专门针对内存小，没有持续电源等小型设备。j2ee：java的企业模块，专门针对企业数据库服务器的连接维护。 手机用到的是用j2me所编出来的小程序 javac：Java编译器 java：Java解释器 jdb：Java调试器 javap：反编译 javadoc：文档生成器 利用编辑器编写Java源程序，源文件名：主类名.java 利用编译器将源程序编译成字节码，字节码文件名：源文件名.class 利用虚拟机（解释器）运行，工作过程：载入、代码校验、解释执行 必须熟练掌握的命令 javac命令：编译器将java源文件编译成字节码文件 java命令：JVM解释执行已经编译好的字节码文件 java属于面向对象语言 具备封装，继承，多态三大特性。 封装：每个类不对外暴露其构造和实现，只展示自身的功能与作用 继承：同一父类的子类共同持有父类的公有（非private）资源 多态：同一父类的子类对于父类公有方法或资源，可以具备不同的表达方式 JVM、JRE 、JDK说明 A:什么是JVM JVM是java虚拟机(JVM Java Virtual Machine)，java程序需要运行在虚拟机上，不同平台有自己的虚拟机，因此java语言可以跨平台 B:什么是JRE（运行环境） 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JRE:JVM+类库+运行工具（java.exe）。 C:什么是JDK（开发环境） JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 运行工具（java.exe） 打包工具(jar.exe)等 D:为什么JDK中包含一个JRE JDK若无JRE则缺少虚拟机，而开发完的程序，需要运行一下看看效果。 E:JDK,JRE,JVM的作用和关系 JDK包含JRE 和开发工具包 JRE包含 核心类库和JVM F：环境配置注意事项 JRE不可以安装在JDK内部（javac无法执行），CLASSPATH最好不配置 java基本数据类型 8大基本数据类型 byte short int char long double boolean float 精度从低到高：byte,short – int–(char) – long – float – double 低精度到高精度（隐式转换）：long a = 1 （系统默认整数为int类型） 高精度到低精度（强制转换）：byte b = (int)a (损失精度) 基本数据类型作为类成员时具有默认值 boolean:false char:0(空格) byte:0 int:0 short:0 Long:0L float:0.0f double:0.0d 注意: 不能对布尔值进行转换 不能把对象类型转换为不相干的类型 在把高容量转换到低容量的时候，强制转换 转换的时候可能存在内存溢出，或者精度问题 除了int和char的包装类是Integer和Character，其他基本数据类型的包装类都是自己的首字母大写 基本数据类型和封装类的区别: 定义不同。封装类是对象，基本数据类型不是； 使用方式不同。封装类需要先new初始化，再通过JVM根据具体情况实例化后赋予定值，基本数据类型可以直接赋值，某些集合类型必须使用包装类，不能使用基本数据类型，如ArrayList 初始值不同。包装类初始值默认为null，基本数据类型根据类型不同而值不同； 存储方式和位置不用。封装类分拆引用和实例，引用存储在栈（stack），具体实例存储在堆（heap），基本数据类型存储在栈中（stack）。 为什么需要包装类: 包装类封装在java.lang包中； 基本数据类型没有toString()方法； 编码过程中只接收对象的情况，比如List中只能存入对象，不能存入基本数据类型；比如一个方法的参数是Object时，不能传入基本数据类型，但可以传入对应的包装类； 比如泛型等等。 JAVA运算符详解 1、算数运算符 ++算数运算符操作数必须是数值类型++ 一元运算符:只有一个操作数 包括：正‘+’，负‘-’，自加‘++’，自减‘–‘ 123”++“和”--“用于数值变量之前，在赋值操作中，先对被”++“或”--“操作变量值先加1或者先减1，然后在进行其他的操作；\"++\"和”--“用于数值变量之后，在赋值操作中，先用被”++“或”--“的操作变量值进行其他的操作，然后在对其值加1或者减1。 二元运算符:有两个操作数，运算符在两个操作数之间，用来完成加减乘除四则运算 包括：加’+’，减’-’，乘’*’，除’/’，取余’%’ 注意： ①数值计算中语法现象——“晋升”，即：byte、short和char(低于int的数据类型)进行算术运算后，结果会自动提升成int类型； ②两个char型运算时，自动转换为int型；当char与别的类型运算时，也会先自动转换为int型的，再做其它类型的自动转换； ③算数运算可以加入小括号&quot;()&quot;提高优先级，优先小括号内运算，再其他运算符运算； ④算数运算前操作数变量必须赋值，反之，报语法错误。 2、关系运算符 等于’==’，不等于’!=’，大于’&gt;’，大于等于’&gt;=’，小于’&lt;’，小于等于’&lt;=’： 关系运算符用于比较两个数值之间的大小，其运算结果为一个逻辑类型(boolean布尔类型)的数值 3、逻辑运算符 逻辑运算符要求操作数的数据类型为逻辑型，其运算结果也是逻辑型值。 逻辑运算的数据和逻辑运算符的运算结果是boolean类型。 逻辑与’&amp;&amp;’，逻辑或’||’，逻辑非’!’，逻辑异或’^’，逻辑与’&amp;’，逻辑或’|’ 123456&amp;(并且) 有false则false|(或者) 有true则true!(非) 非false则true，非true则false^(异或) 相同为false，不同为true&amp;&amp;(短路与) 有false则false,若&amp;&amp;左边表达式或者值为false则右边不进行计算||(短路或) 有true则true,若||左边表达式或者值为true则右边不进行计算 JAVA流程控制 JAVA异常处理 Throwable是所有错误和异常的顶级父类，有两个重要的子类：Exception（异常）和 Error（错误） error 和 exception 的区别？ Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Exception分为编译时异常 CheckedException 和运行时异常 RuntimeException。 12345678910111213当前方法知道如何处理该异常，则用 try…catch 块来处理该异常。当前方法不知道如何处理，则在定义该方法是声明 throws 抛出该异常。被finally控制的语句体一定会执行（前提是JVM没有停止）如果catch里面有return语句，finally的代码会执行，会在在return前执行。throw：1） throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。2） throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常throws：1） throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。2） throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。3） throws 表示出现异常的一种可能性，并不一定会发生这种异常。 JAVA文件处理和IO流 File文件类 File类提供了对文件和目录的所有操作方法，大致可以分为：创建，删除，重命名，判断，获取。 1、创建：创建文件（createNewFile()）和创建目录（mkdir()，mkdirs()）。返回值均是boolean类型，在创建前会自行判断文件或目录是否存在，不存在才去创建。创建目录时推荐使用mkdirs()方法，这个会自动帮你检查并创建不存在的上级目录 2、删除：方法是delete()，返回值boolean，既可以删目录，也可以删文件。 3、重命名：是由renameTo(Filedest)方法完成的，这个方法要求传入一个封装了新路径的File实例，返回值是布尔类型。JDK的开发者对其功能进行了进一步扩充：如果只是文件名不一样，那就是重命名；如果路径和文件名都不一样，那就是先剪切再重命名。 4、判断：有多个方面的判断，首先是类型判断（是目录还是文件？）：isDirectory()，isFile()。其次还有文件状态判断：canRead()是否可读，public boolean canWrite()是否可写，public boolean isHidden() 是否隐藏。还有一个用的最多就是关于文件是否存在的判断：exists()。涉及到File类，常见的逻辑都是先判断文件或目录是否存在，再根据返回结果进一步操作。这些方法的返回值也都是布尔类型。 5、获取：首先是路径的获取，这其中包括了绝对路径，相对路径，父目录的路径，分别是：getAbsolutePath，getPath()，getParent()；其次还有文件名的获取，包括父目录的文件名，分别是：getName()，getParent()；也可以后去父目录的File实例：getParentFile()；获取最后一次的修改时间（毫秒值）lastModified；获取文件大小（字节数）length()；可以获取指定目录下的所有文件夹/文件的名称或者File实例：list()，listFile()；甚至可以获取次抽象路径名指定的分区大小，已使用的字节数和未分配的字节数：getTotalSpace()，getUseSpace()，getFreeSpace()。 IO流 按照流的方向分：输入流（InputStream）和输出流（OutputStream） 按照实现功能分：节点流（可以从或向一个特定的地方（节点）读写数据。例如FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写） 按照数据处理单元分：字节流和字符流。 字节流：多用于读取或书写二进制数据，这些类的基类为InputStream或OutputStream。可以处理所有以bit为单位储存的文件，也就是说可以处理所有的文件，但是在处理字符上的速度不如字符流。 字符流：操作的是为了支持Unicode编码，用于字符国际化，一个字符占用两个字节，这些类的基类为Reader或Writer。该流只能处理字符，但处理字符速度很快 拷贝文件，一个一个字节的拷贝 1234567891011public void t1() throws Exception&#123; FileInputStream fis = new FileInputStream(\"H:\\\\javaio\\\\copy01.txt\"); FileOutputStream fos = new FileOutputStream(\"H:\\\\javaio\\\\copy02.txt\"); int n; //这里面是n等于读取到的字节，当读取到末尾时，返回的是-1，所以这里用！=-1来表示没有读到文件末尾 while((n = fis.read()) != -1)&#123; fos.write(n); &#125; fos.close(); fis.close();&#125; 利用缓冲流进行拷贝，多个字节多个字节拷贝 1234567891011public void t1() throws Exception&#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"H:\\\\javaio\\\\测试.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"H:javaio\\\\测试copy1.avi\")); byte[] b = new byte[2*1024]; int len; while((len = bis.read(b)) != -1)&#123; bos.write(b, 0, len); &#125; bos.close(); bis.close(); &#125; 使用转换流进行文件的拷贝 1234567891011public void t1() throws Exception&#123; InputStreamReader isr = new InputStreamReader(new FileInputStream(\"H:\\\\javaio\\\\copy01.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"H:\\\\javaio\\\\copy02.txt\")); char[] cbuf = new char[1024]; int len; while((len = isr.read(cbuf)) != -1)&#123; osw.write(cbuf, 0, len); &#125; osw.close(); isr.close(); &#125; 使用字符流进行文件的拷贝 1234567891011public void t1() throws Exception&#123; FileReader fr = new FileReader(\"H:\\\\javaio\\\\copy01.txt\"); FileWriter fw = new FileWriter(\"H:\\\\javaio\\\\copy02.txt\"); char[] cbuf = new char[1024]; int len; while((len = fr.read(cbuf)) != -1)&#123; fw.write(cbuf, 0, len); &#125; fw.close(); fr.close(); &#125; 使用字符缓冲流行文件的拷贝 1234567891011121314151617public void t1() throws Exception&#123; BufferedReader br = new BufferedReader(new FileReader(\"H:\\\\javaio\\\\copy01.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"H:\\\\javaio\\\\copy02.txt\")); // char[] cbuf = new char[1024]; // int len; // while((len=br.read(cbuf)) != -1)&#123; // bw.write(cbuf, 0, len); // &#125; //BufferedReader提供了readLine方法，可以不再使用字节读取方式 String readline; while((readline = br.readLine()) != null)&#123; bw.write(readline); bw.newLine(); &#125; bw.close(); br.close(); &#125; 其他流 ObjectInputStream和ObjectOutputStream（对象流） ObjectInputStream（对象输入流）继承于InputStream，ObjectOutputStream（对象输出流）继承于OutputStream。对象流是将对象的基本数据和图形实现持久存储。ObjectOutputStream实际是在对流进行序列化操作，ObjectInputStream实际是在对流进行反序列化操作，要实现序列化，必须实现Serializable接口，否则是无法进行序列化和反序列化的，如果对象中的属性加了transient和static关键字的话，则该属性不会被序列化。 补充：序列化与反序列化 数据传输过程中，都会默认采用二进制文件的方式，因为计算机的底层识别方式就是二进制，不依赖任何运行环境或是程序设计语言，所以这是实现数据传输跨平台跨网络的基础。*序列化可以直接将java对象转化为一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象（反序列化），*这一过程甚至可以通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。 注：实现序列化的对象必须实现Serializable接口 PrintStream和PrintWriter（打印流） PrintStream（可以将字节流封装成打印流）继承于FilterOutputStream，FilterOutputStream是继承于OutputStream的；PrintWriter（可以将字节流、字符流封装成打印流）继承于Writer的。 集合","categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Vue中使用iframe引用html页面已经vue和html页面方法的调用","slug":"Vue中使用iframe引用html页面已经vue和html页面方法的调用","date":"2020-07-14T14:29:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2020/07/14/Vue中使用iframe引用html页面已经vue和html页面方法的调用/","link":"","permalink":"http://xuhao008.github.io/2020/07/14/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8iframe%E5%BC%95%E7%94%A8html%E9%A1%B5%E9%9D%A2%E5%B7%B2%E7%BB%8Fvue%E5%92%8Chtml%E9%A1%B5%E9%9D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/","excerpt":"Vue中使用iframe引用html页面已经vue和html页面方法的调用 当我们需要在vue中使用其他模块或者其他地方的一些html页面功能时，我们可以使用iframe去引用html页面，实现他们的交互 首先我们可以再vue页面中使用标签引用html页面 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;iframe name&#x3D;&quot;iframeMap&quot; id&#x3D;&quot;iframeMapViewComponent&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;470px&quot; v-bind:src&#x3D;&quot;smgHtmlPath&quot; frameborder&#x3D;&quot;0&quot; scrolling&#x3D;&quot;no&quot; ref&#x3D;&quot;iframeDom&quot; &gt;&lt;&#x2F;iframe&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 其中src就是我们html的地址，我们可以在data中定义smgHtmlPath属性，在我们的created方法中初始化，为该属性赋予初始值 如果页面加载出来了，我们就可以开始vue页面和html页面的交互了 如果我们需要vue页面调用html页面方法，我们可以使用如下代码 123mounted() &#123; this.iframeWin &#x3D; this.$refs.iframeDom.contentWindow; &#125;, 首先在我们的mounted方法中得到iframe对象 在vue页面使用postMessage的API向html页面发送请求数据，因为我们的vue和html页面可能不在同一域名，所以会产生跨域的问题，这里我们使用的postMessage可以实现跨域，我这里在google和IE11测试都是可以跨域的","text":"Vue中使用iframe引用html页面已经vue和html页面方法的调用 当我们需要在vue中使用其他模块或者其他地方的一些html页面功能时，我们可以使用iframe去引用html页面，实现他们的交互 首先我们可以再vue页面中使用标签引用html页面 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;iframe name&#x3D;&quot;iframeMap&quot; id&#x3D;&quot;iframeMapViewComponent&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;470px&quot; v-bind:src&#x3D;&quot;smgHtmlPath&quot; frameborder&#x3D;&quot;0&quot; scrolling&#x3D;&quot;no&quot; ref&#x3D;&quot;iframeDom&quot; &gt;&lt;&#x2F;iframe&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 其中src就是我们html的地址，我们可以在data中定义smgHtmlPath属性，在我们的created方法中初始化，为该属性赋予初始值 如果页面加载出来了，我们就可以开始vue页面和html页面的交互了 如果我们需要vue页面调用html页面方法，我们可以使用如下代码 123mounted() &#123; this.iframeWin &#x3D; this.$refs.iframeDom.contentWindow; &#125;, 首先在我们的mounted方法中得到iframe对象 在vue页面使用postMessage的API向html页面发送请求数据，因为我们的vue和html页面可能不在同一域名，所以会产生跨域的问题，这里我们使用的postMessage可以实现跨域，我这里在google和IE11测试都是可以跨域的 123loadSmgxmlModels(data) &#123; this.iframeWin.postMessage(data,\"*\")&#125; 这里的data就是我们要传递给html页面的数据 “*”,这里代表的是所有地址可以接收到，我们也可以指定地址，例如：www.baidu.com 在html页面的标签中编写监听方法，用来监听我们的请求，获取数据 1234567window.addEventListener(&#39;message&#39;, function(ev) &#123; &#x2F;&#x2F; 当我们是父子窗口进行消息传递时，可以使用此判断，只接受父窗口传递来的消息, if (ev.source !&#x3D;&#x3D; window.parent) return; var data &#x3D; ev.data; console.log(&quot;vue传递的数据为：&quot;+data); &#x2F;&#x2F;下面可以调用我们html页面js中的方法，使用传递的数据进行操作了&#125;, false); 这里我们监听的就是message，可以获取数据。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://xuhao008.github.io/tags/vue/"}]},{"title":"VUE，localStorage（本地储存）储存数组对象，取出时产生错误","slug":"VUE，localStorage（本地储存）储存数组对象，取出时产生错误","date":"2020-06-22T12:05:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2020/06/22/VUE，localStorage（本地储存）储存数组对象，取出时产生错误/","link":"","permalink":"http://xuhao008.github.io/2020/06/22/VUE%EF%BC%8ClocalStorage%EF%BC%88%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98%EF%BC%89%E5%82%A8%E5%AD%98%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%96%E5%87%BA%E6%97%B6%E4%BA%A7%E7%94%9F%E9%94%99%E8%AF%AF/","excerpt":"VUE，localStorage（本地储存）储存数组对象，取出时产生错误 在开发中通过以下代码储存json数组对象时 数据格式： 1[&#123;\"refId\":\"1\",\"type\":\"1\"&#125;,&#123;\"refId\":\"2\",\"type\":\"2\"&#125;,&#123;\"refId\":\"3\",\"type\":\"3\"&#125;] 储存： 1localStorage.setItem( \"processBR\", JSON.stringify(this.$refs[\"assemblyChildNodeTable\"].selectedRows)); 在其他页面取出时无法识别，导致通过for取出时，无法识别数组中的单个对象，而是直接当做字符串一个个输出，通过使用eval()转换后，可识别数组中的单个对象，按对象循环遍历 1234567891011let relaAoprod = [];let packJson = eval(\"(\" + localStorage.getItem(\"processBR\") + \")\");for (var i in packJson) &#123; let prod = &#123;&#125;; prod.oid = packJson[i].refId; //工艺节点id prod.refType = packJson[i].type; // 产品节点类型 (prod.prodType = this.leftNodeData.type), // 工艺节点的类型 (prod.relationType = this.relationType), // 关联关系 0-消耗，1-拆除 (prod.roId = this.leftNodeData.id), // 产品id relaAoprod.push(prod); &#125;","text":"VUE，localStorage（本地储存）储存数组对象，取出时产生错误 在开发中通过以下代码储存json数组对象时 数据格式： 1[&#123;\"refId\":\"1\",\"type\":\"1\"&#125;,&#123;\"refId\":\"2\",\"type\":\"2\"&#125;,&#123;\"refId\":\"3\",\"type\":\"3\"&#125;] 储存： 1localStorage.setItem( \"processBR\", JSON.stringify(this.$refs[\"assemblyChildNodeTable\"].selectedRows)); 在其他页面取出时无法识别，导致通过for取出时，无法识别数组中的单个对象，而是直接当做字符串一个个输出，通过使用eval()转换后，可识别数组中的单个对象，按对象循环遍历 1234567891011let relaAoprod = [];let packJson = eval(\"(\" + localStorage.getItem(\"processBR\") + \")\");for (var i in packJson) &#123; let prod = &#123;&#125;; prod.oid = packJson[i].refId; //工艺节点id prod.refType = packJson[i].type; // 产品节点类型 (prod.prodType = this.leftNodeData.type), // 工艺节点的类型 (prod.relationType = this.relationType), // 关联关系 0-消耗，1-拆除 (prod.roId = this.leftNodeData.id), // 产品id relaAoprod.push(prod); &#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://xuhao008.github.io/tags/vue/"}]},{"title":"主页","slug":"图片","date":"2020-04-24T22:05:12.000Z","updated":"2020-08-06T09:50:14.766Z","comments":true,"path":"2020/04/25/图片/","link":"","permalink":"http://xuhao008.github.io/2020/04/25/%E5%9B%BE%E7%89%87/","excerpt":"","text":"","categories":[],"tags":[{"name":"image","slug":"image","permalink":"http://xuhao008.github.io/tags/image/"}]},{"title":"整理JDK8新特性","slug":"整理JDK8新特性","date":"2019-08-10T22:05:12.000Z","updated":"2020-08-05T03:27:43.142Z","comments":true,"path":"2019/08/11/整理JDK8新特性/","link":"","permalink":"http://xuhao008.github.io/2019/08/11/%E6%95%B4%E7%90%86JDK8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"整理JDK8新特性 目录 static？default？lamda表达式？ 常见的函数式接口 方法引用 Stream总结 Optinal用法介绍 新的日期API LocalDate | LocalTime | LocalDateTime static？default？lamda表达式？ 12345678910111213141516171819202122232425package com.wanke.microgrid.mgcc;@FunctionalInterfacepublic interface NullAnnotation &#123; //抽象方法 public void getName(String a); boolean equals(Object obj); //default方法 default void getAge()&#123; System.out.println(\"age\"); &#125; default void getAge1()&#123; &#125; //静态方法 static void static1()&#123; System.out.println(\"static1\"); &#125; static void static2()&#123; &#125;&#125;","text":"整理JDK8新特性 目录 static？default？lamda表达式？ 常见的函数式接口 方法引用 Stream总结 Optinal用法介绍 新的日期API LocalDate | LocalTime | LocalDateTime static？default？lamda表达式？ 12345678910111213141516171819202122232425package com.wanke.microgrid.mgcc;@FunctionalInterfacepublic interface NullAnnotation &#123; //抽象方法 public void getName(String a); boolean equals(Object obj); //default方法 default void getAge()&#123; System.out.println(\"age\"); &#125; default void getAge1()&#123; &#125; //静态方法 static void static1()&#123; System.out.println(\"static1\"); &#125; static void static2()&#123; &#125;&#125; 1234567891011121314package com.wanke.microgrid.mgcc;public class Test&#123; public static void main(String[] args) &#123; String a = \"aaaa\"; //Lambda表达式 NullAnnotation annotation = (f) -&gt; System.out.println(f); annotation.getName(a); //defalut方法属于对象的默认方法 annotation.getAge(); //static属于类的方法 NullAnnotation.static1(); &#125;&#125; 运行结果： 123aaaaagestatic1 @FunctionalInterface标记接口为函数式接口，函数式接口有且只能有一个抽象方法，或许大家会问你不是写了两个抽象方法吗？java.lang.Object根对象有equals方法吧，所以实现该类的时候是不是不必须要实现这个接口（所有的类都是实现java.lang.Object的）。Lambda表达式是基于函数式接口的。 常见的函数式接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.wanke.microgrid.mgcc;import java.util.Comparator;import java.util.Objects;import java.util.function.*;public class Test &#123; //Consumer消费型接口，有参无返回 static void testConsumer(Integer x, Consumer&lt;Integer&gt; consumer) &#123; consumer.accept(x); &#125; //suplier供给型接口，无参有返回值 static void testSupplier(Supplier&lt;Integer&gt; supplier) &#123; System.out.println(supplier.get()); &#125; static Integer getInteger() &#123; return 2; &#125; //函数式接口，有参有返回值 static void testFunction(Integer num, Function&lt;Integer, Integer&gt; function) &#123; System.out.println(function.apply(num)); &#125; //断言型接口，有参有返回值，返回值是boolean类型 static void testPredicate(Integer num, Predicate&lt;Integer&gt; predicate) &#123; System.out.println(predicate.test(num)); &#125; //介绍部分拓展接口 //BinaryOperator (R apply(T t, U u) -&gt;两个输入，一个输出,而且类型一样) public static void binaryOperatorCompute(Integer para1, Integer para2, BinaryOperator&lt;Integer&gt; binaryOperator) &#123; //使用自定义BinaryOperator System.out.println(binaryOperator.apply(para1, para2)); Comparator&lt;Integer&gt; cpt2 = (x, y) -&gt; Integer.compare(x, y); //静态方法传入比较器生成BinaryOperator BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy(cpt2); System.out.println(min.apply(para1, para2)); &#125; //toIntFunction (int applyAsInt(T t, U u) -&gt;两个输入，一个int输出) public static void testToIntFunction(Integer para1, Integer para2, ToIntBiFunction&lt;Integer, Integer&gt; toIntBiFunction) &#123; System.out.println(toIntBiFunction.applyAsInt(para1, para2)); &#125; //BiFunction (R apply(T t, U u) -&gt;两个输入，一个输出) public static void testBi(Integer para1,Integer para2,BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; BiFunction&lt;Integer, Integer, Integer&gt; newBi = biFunction.andThen(function); System.out.println(newBi.apply(para1,para2)); &#125; //如何看出输入输出，以BiFunction为例 //源码如下://package java.util.function;////import java.util.Objects;//// /**// * Represents a function that accepts two arguments and produces a result.// * This is the two-arity specialization of &#123;@link Function&#125;.// *// * &lt;p&gt;This is a &lt;a href=\"package-summary.html\"&gt;functional interface&lt;/a&gt;// * whose functional method is &#123;@link #apply(Object, Object)&#125;.// *// * @param &lt;T&gt; the type of the first argument to the function// * @param &lt;U&gt; the type of the second argument to the function// * @param &lt;R&gt; the type of the result of the function// *// * @see Function// * @since 1.8// */// @FunctionalInterface// public interface BiFunction&lt;T, U, R&gt; &#123;//// /**// * Applies this function to the given arguments.// *// * @param t the first function argument// * @param u the second function argument// * @return the function result// */// R apply(T t, U u);//// /**// * Returns a composed function that first applies this function to// * its input, and then applies the &#123;@code after&#125; function to the result.// * If evaluation of either function throws an exception, it is relayed to// * the caller of the composed function.// *// * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the// * composed function// * @param after the function to apply after this function is applied// * @return a composed function that first applies this function and then// * applies the &#123;@code after&#125; function// * @throws NullPointerException if after is null// */// default &lt;V&gt; java.util.function.BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;// Objects.requireNonNull(after);// return (T t, U u) -&gt; after.apply(apply(t, u));// &#125;// &#125;//函数式接口类型的唯一抽象方法 R apply(T t, U u);显然是量输入一输出，而且是泛型 public static void main(String[] args) &#123; testConsumer(1, x -&gt; System.out.println(x)); testSupplier(() -&gt; getInteger()); testFunction(100, x -&gt; x + 100); testPredicate(100, x -&gt; x.equals(100)); binaryOperatorCompute(1, 2, (x, y) -&gt; x + y); testToIntFunction(3, 4, (x, y) -&gt; x + y + 1); testBi(5,9,(x,y)-&gt;&#123;int z = x+y;return z;&#125;,x-&gt;x + 3); &#125;&#125; 运行结果： 1234567812200true31817 总之jdk8提供了一种方便的方式让我们传递函数，就像传递参数一样，大家对照着可以看看js的回调。 方法引用 定义了4个方法的Car这个类作为例子，区分Java中支持的4种不同的方法引用。 1234567891011121314151617181920212223242526public static class Car &#123; public static Car create( final Supplier&lt; Car &gt; supplier ) &#123; return supplier.get(); &#125; public static void collide( final Car car ) &#123; System.out.println( \"Collided \" + car.toString() ); &#125; public void follow( final Car another ) &#123; System.out.println( \"Following the \" + another.toString() ); &#125; public void repair() &#123; System.out.println( \"Repaired \" + this.toString() ); &#125;&#125; 第一种方法引用是构造器引用，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new。请注意构造器没有参数。 12final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用是静态方法引用，它的语法是Class::static_method。请注意这个方法接受一个Car类型的参数。 1cars.forEach( Car::collide ); 第三种方法引用是特定类的任意对象的方法引用，它的语法是Class::method。请注意，这个方法没有参数。 1cars.forEach( Car::repair ); 第四种方法引用是特定对象的方法引用，它的语法是instance::method。请注意，这个方法接受一个Car类型的参数 12final Car police = Car.create( Car::new );cars.forEach( police::follow ) 方法和函数都有输入输出，本质上是类似的，所以我们可以引用方法来代替lamda表达式，这样或许好理解一点。 Stream总结 Stream的操作符大体上分为两种：中间操作符和终止操作符 中间操作符 对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。 中间操作符包含8种(排除了parallel,sequential,这两个操作并不涉及到对数据流的加工操作)： 1.map(mapToInt,mapToLong,mapToDouble) 转换操作符，把比如A-&gt;B，这里默认提供了转int，long，double的操作符。 2.flatmap(flatmapToInt,flatmapToLong,flatmapToDouble) 拍平操作比如把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。 3.limit 限流操作，比如数据流中有10个 我只要出前3个就可以使用。 4.distint 去重操作，对重复元素去重，底层使用了equals方法。 5.filter 过滤操作，把不想要的数据过滤。 6.peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。 skip 跳过操作，跳过某些元素。 7.sorted(unordered) 排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。 终止操作符 数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。 1.collect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的 Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors。 2.count 统计操作，统计最终的数据个数。 3.findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。 4.noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。 5.min、max 最值操作，需要自定义比较器，返回数据流中最大最小的值。 6.reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。 7.forEach、forEachOrdered 遍历操作，这里就是对最终的数据进行消费了。 8.toArray 数组操作，将数据流的元素转换成数组。 parallel会利用多核，但要注意线程安全(利用外部变量时可能会造成线程安全问题，外部变量指的是流操作外面申明的变量) Optinal用法介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171//Optional.of()或者Optional.ofNullable()：创建Optional对象，差别在于of不允许参数是null，而ofNullable则无限制。 // 参数不能是null Optional&lt;Integer&gt; optional1 = Optional.of(1); // 参数可以是null Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); // 参数可以是非null Optional&lt;Integer&gt; optional3 = Optional.ofNullable(2); //Optional.empty()：所有null包装成的Optional对象： Optional&lt;Integer&gt; optional4 = Optional.ofNullable(null); Optional&lt;Integer&gt; optional5 = Optional.ofNullable(null); System.out.println(optional4 == optional5);// true System.out.println(optional5 == Optional.&lt;Integer&gt;empty());// true Object o1 = Optional.&lt;Integer&gt;empty(); Object o2 = Optional.&lt;String&gt;empty(); System.out.println(o1 == o2);// true //isPresent()：判断值是否存在 Optional&lt;Integer&gt; optional6 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional7 = Optional.ofNullable(null);// isPresent判断值是否存在 System.out.println(optional6.isPresent() == true); System.out.println(optional7.isPresent() == false);Optional&lt;Integer&gt; optional8 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional9 = Optional.ofNullable(null); // 如果不是null,调用Consumer optional8.ifPresent(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer t) &#123; System.out.println(\"value is \" + t); &#125; &#125;);// null,不调用Consumer optional9.ifPresent(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer t) &#123; System.out.println(\"value is \" + t); &#125; &#125;);//orElse(value)：如果optional对象保存的值不是null，则返回原来的值，否则返回value Optional&lt;Integer&gt; optional10 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional11 = Optional.ofNullable(null);// orElse System.out.println(optional10.orElse(1000) == 1);// true System.out.println(optional11.orElse(1000) == 1000);// true //orElseGet(Supplier supplier)：功能与orElse一样，只不过orElseGet参数是一个对象 Optional&lt;Integer&gt; optional12 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional13 = Optional.ofNullable(null); System.out.println(optional12.orElseGet(() -&gt; &#123; return 1000; &#125;) == 1);//trueSystem.out.println(optional3.orElseGet(() -&gt; &#123; return 1000; &#125;) == 1000);//true//orElseThrow()：值不存在则抛出异常，存在则什么不做，有点类似Guava的Precoditions Optional&lt;Integer&gt; optional14 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional15 = Optional.ofNullable(null);optional14.orElseThrow(()-&gt;&#123;throw new IllegalStateException();&#125;);try &#123; // 抛出异常 optional15.orElseThrow(()-&gt;&#123;throw new IllegalStateException();&#125;); &#125; catch(IllegalStateException e ) &#123; e.printStackTrace(); &#125;//filter(Predicate)：判断Optional对象中保存的值是否满足Predicate，并返回新的Optional。 Optional&lt;Integer&gt; optional16 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional17 = Optional.ofNullable(null); Optional&lt;Integer&gt; filter1 = optional16.filter((a) -&gt; a == null); Optional&lt;Integer&gt; filter2 = optional16.filter((a) -&gt; a == 1); Optional&lt;Integer&gt; filter3 = optional17.filter((a) -&gt; a == null); System.out.println(filter1.isPresent());// false System.out.println(filter2.isPresent());// true System.out.println(filter2.get().intValue() == 1);// true System.out.println(filter3.isPresent());// false//map(Function)：对Optional中保存的值进行函数运算，并返回新的Optional(可以是任何类型) Optional&lt;Integer&gt; optional18 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional19 = Optional.ofNullable(null);Optional&lt;String&gt; str1Optional = optional18.map((a) -&gt; \"key\" + a); Optional&lt;String&gt; str2Optional = optional19.map((a) -&gt; \"key\" + a); //flatMap()：功能与map()相似，差别请看如下代码。flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。 Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1);Optional&lt;Optional&lt;String&gt;&gt; str3Optional = optional1.map((a) -&gt; &#123; return Optional.&lt;String&gt;of(\"key\" + a); &#125;); Optional&lt;String&gt; str4Optional = optional1.flatMap((a) -&gt; &#123; return Optional.&lt;String&gt;of(\"key\" + a); &#125;); System.out.println(str3Optional.get().get());// key1 System.out.println(str4Optional.get());// key1//Optional应用示例 Person person = new Person(); Car car = new Car(); Insurance insurance = new Insurance(); insurance.setName(\"aa\"); car.setInsurance(insurance); person.setCar(car); String insuranceName = Optional.ofNullable(person) .map((p) -&gt; p.getCar()) .map(c -&gt; c.getInsurance()) .map(i -&gt; i.getName()).orElse(\"unknown\");System.out.println(insuranceName);&#125; static class Person &#123;private Car car;public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; &#125; static class Car &#123;private Insurance insurance;public Insurance getInsurance() &#123; return insurance; &#125;public void setInsurance(Insurance insurance) &#123; this.insurance = insurance; &#125; &#125; static class Insurance &#123;private String name;public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 新的日期API LocalDate | LocalTime | LocalDateTime 新的日期API都是不可变的，更使用于多线程的使用环境中 12345678910111213141516171819202122232425@Testpublic void test()&#123; // 从默认时区的系统时钟获取当前的日期时间。不用考虑时区差 LocalDateTime date = LocalDateTime.now(); //2018-07-15T14:22:39.759 System.out.println(date); System.out.println(date.getYear()); System.out.println(date.getMonthValue()); System.out.println(date.getDayOfMonth()); System.out.println(date.getHour()); System.out.println(date.getMinute()); System.out.println(date.getSecond()); System.out.println(date.getNano()); // 手动创建一个LocalDateTime实例 LocalDateTime date2 = LocalDateTime.of(2017, 12, 17, 9, 31, 31, 31); System.out.println(date2); // 进行加操作，得到新的日期实例 LocalDateTime date3 = date2.plusDays(12); System.out.println(date3); // 进行减操作，得到新的日期实例 LocalDateTime date4 = date3.minusYears(2); System.out.println(date4);&#125; 1234567891011121314151617181920212223242526272829@Test public void test3()&#123; // Duration:计算两个时间之间的间隔 // Period：计算两个日期之间的间隔 Instant ins1 = Instant.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Instant ins2 = Instant.now(); Duration dura = Duration.between(ins1, ins2); System.out.println(dura); System.out.println(dura.toMillis()); System.out.println(\"======================\"); LocalTime localTime = LocalTime.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LocalTime localTime2 = LocalTime.now(); Duration du2 = Duration.between(localTime, localTime2); System.out.println(du2); System.out.println(du2.toMillis()); &#125; 1234567891011121314@Test public void test4()&#123; LocalDate localDate =LocalDate.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LocalDate localDate2 = LocalDate.of(2016,12,12); Period pe = Period.between(localDate, localDate2); System.out.println(pe); &#125; 123456789101112131415161718192021222324252627282930313233@Test public void test5()&#123; // temperalAdjust 时间校验器 // 例如获取下周日 下一个工作日 LocalDateTime ldt1 = LocalDateTime.now(); System.out.println(ldt1); // 获取一年中的第一天 LocalDateTime ldt2 = ldt1.withDayOfYear(1); System.out.println(ldt2); // 获取一个月中的第一天 LocalDateTime ldt3 = ldt1.withDayOfMonth(1); System.out.println(ldt3); LocalDateTime ldt4 = ldt1.with(TemporalAdjusters.next(DayOfWeek.FRIDAY)); System.out.println(ldt4); // 获取下一个工作日 LocalDateTime ldt5 = ldt1.with((t) -&gt; &#123; LocalDateTime ldt6 = (LocalDateTime)t; DayOfWeek dayOfWeek = ldt6.getDayOfWeek(); if (DayOfWeek.FRIDAY.equals(dayOfWeek))&#123; return ldt6.plusDays(3); &#125; else if (DayOfWeek.SATURDAY.equals(dayOfWeek))&#123; return ldt6.plusDays(2); &#125; else &#123; return ldt6.plusDays(1); &#125; &#125;); System.out.println(ldt5); &#125; 12345678910111213141516171819202122232425@Test public void test6()&#123; // DateTimeFormatter: 格式化时间/日期 // 自定义格式 LocalDateTime ldt = LocalDateTime.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\"); String strDate1 = ldt.format(formatter); String strDate = formatter.format(ldt); System.out.println(strDate); System.out.println(strDate1); // 使用api提供的格式 DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE; LocalDateTime ldt2 = LocalDateTime.now(); String strDate3 = dtf.format(ldt2); System.out.println(strDate3); // 解析字符串to时间 DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); LocalDateTime time = LocalDateTime.now(); String localTime = df.format(time); LocalDateTime ldt4 = LocalDateTime.parse(\"2017-09-28 17:07:05\",df); System.out.println(\"LocalDateTime转成String类型的时间：\"+localTime); System.out.println(\"String类型的时间转成LocalDateTime：\"+ldt4); &#125; 12345678910111213// ZoneTime ZoneDate ZoneDateTime @Test public void test7()&#123; LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(now); LocalDateTime now2 = LocalDateTime.now(); ZonedDateTime zdt = now2.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); set.stream().forEach(System.out::println); &#125; LocalDate 1234567891011121314public static void localDateTest() &#123; //获取当前日期,只含年月日 固定格式 yyyy-MM-dd 2018-05-04 LocalDate today = LocalDate.now(); // 根据年月日取日期，5月就是5， LocalDate oldDate = LocalDate.of(2018, 5, 1); // 根据字符串取：默认格式yyyy-MM-dd，02不能写成2 LocalDate yesteday = LocalDate.parse(\"2018-05-03\");// 如果不是闰年 传入29号也会报错 LocalDate.parse(\"2018-02-29\"); &#125; 1234567891011121314151617/** * 日期转换常用,第一天或者最后一天... */ public static void localDateTransferTest()&#123; //2018-05-04 LocalDate today = LocalDate.now(); // 取本月第1天：2018-05-01 LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); // 取本月第2天：2018-05-02 LocalDate secondDayOfThisMonth = today.withDayOfMonth(2); // 取本月最后一天，再也不用计算是28，29，30还是31：2018-05-31 LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); // 取下一天：2018-06-01 LocalDate firstDayOf2015 = lastDayOfThisMonth.plusDays(1); // 取2018年10月第一个周三 so easy?：2018-10-03 LocalDate thirdMondayOf2018 = LocalDate.parse(\"2018-10-01\").with(TemporalAdjusters.firstInMonth(DayOfWeek.WEDNESDAY)); &#125; LocalTime 1234567public static void localTimeTest()&#123; //16:25:46.448(纳秒值) LocalTime todayTimeWithMillisTime = LocalTime.now(); //16:28:48 不带纳秒值 LocalTime todayTimeWithNoMillisTime = LocalTime.now().withNano(0); LocalTime time1 = LocalTime.parse(\"23:59:59\"); &#125; LocalDateTime 12345678//转化为时间戳 毫秒值 long time1 = LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli(); System.out.println(time1); //时间戳转化为localdatetime DateTimeFormatter df= DateTimeFormatter.ofPattern(\"YYYY-MM-dd HH:mm:ss.SSS\"); System.out.println(df.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(time1),ZoneId.of(\"Asia/Shanghai\"))));","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://xuhao008.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"记录一次java使用processBuilder调用exe执行文件处理的代码","slug":"记录一次java使用processBuilder调用exe执行文件处理的代码","date":"2019-06-22T15:05:12.000Z","updated":"2020-08-05T03:27:43.142Z","comments":true,"path":"2019/06/22/记录一次java使用processBuilder调用exe执行文件处理的代码/","link":"","permalink":"http://xuhao008.github.io/2019/06/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1java%E4%BD%BF%E7%94%A8processBuilder%E8%B0%83%E7%94%A8exe%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"记录一次java使用processBuilder调用exe执行文件处理的代码 ProcessBuilder 是jdk1.5以后的类，在这以前一直是直接用process。 具体区别和联系可以查看下方博客 https://honeypps.com/java/process-builder-quick-start/ 该方法调用的是C#开发的一个exe，dll用来生成PDF文件，我们需要给该方法传递参数，我这里path传递的是一个字符串，传递的信息是看你的exe需要。 12345678910111213141516171819202122232425262728293031323334353637public boolean generatePdfFromExe(String path) &#123; String exePath=\"E:\\\\ITextSharpTest\\\\ITextSharpTest.exe\"; BufferedReader br=null; BufferedReader brError=null; try &#123; //执行exe ,exePath可以为字符串(exe存放路径)也可为数组 log.info(\"执行exe文件！\"); ProcessBuilder pr= new ProcessBuilder(exePath,path); process p=pr.start(); String line = null; br = new BufferedReader(new InputStreamReader(p.getInputStream())); brError = new BufferedReader(new InputStreamReader(p.getErrorStream())); log.info(\"开始获取子进程输出流信息和错误流信息\"); while ((line = br.readLine()) != null || (line = brError.readLine()) != null) &#123; //输出exe输出的信息以及错误信息 System.out.println(line); &#125; log.info(\"调用exe方法完成\"); &#125; catch (Exception e) &#123; e.printStackTrace(); log.info(\"调用exe生成PDF过程出现错误\"); log.info(\"错误信息为:\"+e.getMessage()); return false; &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); log.info(\"释放输出流！\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; log.info(\"调用exe生成PDF成功！\"); return true; &#125;","text":"记录一次java使用processBuilder调用exe执行文件处理的代码 ProcessBuilder 是jdk1.5以后的类，在这以前一直是直接用process。 具体区别和联系可以查看下方博客 https://honeypps.com/java/process-builder-quick-start/ 该方法调用的是C#开发的一个exe，dll用来生成PDF文件，我们需要给该方法传递参数，我这里path传递的是一个字符串，传递的信息是看你的exe需要。 12345678910111213141516171819202122232425262728293031323334353637public boolean generatePdfFromExe(String path) &#123; String exePath=\"E:\\\\ITextSharpTest\\\\ITextSharpTest.exe\"; BufferedReader br=null; BufferedReader brError=null; try &#123; //执行exe ,exePath可以为字符串(exe存放路径)也可为数组 log.info(\"执行exe文件！\"); ProcessBuilder pr= new ProcessBuilder(exePath,path); process p=pr.start(); String line = null; br = new BufferedReader(new InputStreamReader(p.getInputStream())); brError = new BufferedReader(new InputStreamReader(p.getErrorStream())); log.info(\"开始获取子进程输出流信息和错误流信息\"); while ((line = br.readLine()) != null || (line = brError.readLine()) != null) &#123; //输出exe输出的信息以及错误信息 System.out.println(line); &#125; log.info(\"调用exe方法完成\"); &#125; catch (Exception e) &#123; e.printStackTrace(); log.info(\"调用exe生成PDF过程出现错误\"); log.info(\"错误信息为:\"+e.getMessage()); return false; &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); log.info(\"释放输出流！\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; log.info(\"调用exe生成PDF成功！\"); return true; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xuhao008.github.io/tags/java/"}]},{"title":"Spring Cloud服务网关 zuul 快速入门","slug":"Spring Cloud服务网关 zuul 快速入门","date":"2019-06-20T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/06/21/Spring Cloud服务网关 zuul 快速入门/","link":"","permalink":"http://xuhao008.github.io/2019/06/21/Spring%20Cloud%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%20zuul%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"前言： 上篇博客中，我们快速搭建了一个Spring Cloud微服务的dome，那么这个博客就是在哪个dome的基础上开始讲解一下服务网关zuul的使用，zuul的作用我在我的前面博客中也有提到，这里就不多说。 上次和这次dome的代码已上传到github，需要自取： https://github.com/xuhao008/Spring-Cloud 一、Zuul网关的基本知识 首先网关顾名思义，就像我们生活中的海关，你必须具备一定条件就可以通过，所有我们的网关也就是这样，主要是过滤或拦截，当我们的用户访问服务的时候，通过网关的验证，然后转发到相对应的服务。 Zuul过滤器生命周期 Zuul大部分功能都是通过过滤器来实现的，Zuul定义了4种标准的过滤器类型，这些过滤器类型对应于请求的典型生命周期： pre: 这种过滤器在请求被路由之前调用。可利用这种过滤器实现身份验证、在集群中选择请求的微服务，记录调试信息等。 routing: 这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用apache httpclient或netflix ribbon请求微服务。 post: 这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的http header、收集统计信息和指标、将响应从微服务发送给客户端等。 error: 在其他阶段发送错误时执行该过滤器。 二、快速搭建zuul网关 创建一个Maven子项目 选择项目创建完毕，我们就来编写pom.xml，yml配置和启动类 1、导入maven坐标依赖 pom.xml 12345678910111213&lt;dependencies&gt; &lt;!--eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--zuul网关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;","text":"前言： 上篇博客中，我们快速搭建了一个Spring Cloud微服务的dome，那么这个博客就是在哪个dome的基础上开始讲解一下服务网关zuul的使用，zuul的作用我在我的前面博客中也有提到，这里就不多说。 上次和这次dome的代码已上传到github，需要自取： https://github.com/xuhao008/Spring-Cloud 一、Zuul网关的基本知识 首先网关顾名思义，就像我们生活中的海关，你必须具备一定条件就可以通过，所有我们的网关也就是这样，主要是过滤或拦截，当我们的用户访问服务的时候，通过网关的验证，然后转发到相对应的服务。 Zuul过滤器生命周期 Zuul大部分功能都是通过过滤器来实现的，Zuul定义了4种标准的过滤器类型，这些过滤器类型对应于请求的典型生命周期： pre: 这种过滤器在请求被路由之前调用。可利用这种过滤器实现身份验证、在集群中选择请求的微服务，记录调试信息等。 routing: 这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用apache httpclient或netflix ribbon请求微服务。 post: 这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的http header、收集统计信息和指标、将响应从微服务发送给客户端等。 error: 在其他阶段发送错误时执行该过滤器。 二、快速搭建zuul网关 创建一个Maven子项目 选择项目创建完毕，我们就来编写pom.xml，yml配置和启动类 1、导入maven坐标依赖 pom.xml 12345678910111213&lt;dependencies&gt; &lt;!--eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--zuul网关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、在resources下创建application.ym配置文件，并编写 application.yml 123456789101112131415161718192021222324server: port: 7777spring: application: name: service-zuuleureka: client: service-url: defaultZone: http://localhost:8081/eureka instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;zuul: routes: #服务名称，随便取 service-a: #用什么路径取服务对应的服务 path: /a/** #serviceId，对应了服务名称 serviceId: service-a #url: http://localhost:8888/ #也可以使用请求路径，不用服务名称 service-b: path: /b/** serviceId: service-b 3、编写启动类 ZuulApplication.java 12345678@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class,args); &#125;&#125; 编写完毕以后，就可以启动我们的服务和网关了 然后我们访问：http://localhost:7777/b/hello 三、设置网关的过滤器 刚刚我们已经成功搭建和设置了网关，虽然可以通过网关服务其他服务了，但是我们都是网关最重要的功能是拦截和过滤，我们刚刚还没有涉及到，选择我们一起来看看。 首先我们创建一个类，继承ZuulFilter ，实现它的4个方法 filterType(),用来设置过滤类型 filterOrder(), 设置过过滤器优先级,数字越大，优先级越低 shouldFilter，返回true或false，表示是否开启过滤 run(),一些自定义的过滤信息方法 下面我们开始编写： 创建com.xkkj.filter包，创建TokenFilter.java 1234567891011121314151617181920212223242526272829303132333435363738394041@Componentpublic class TokenFilter extends ZuulFilter &#123; @Override public String filterType() &#123; // 可以在请求被路由之前调用 return \"pre\"; &#125; @Override public int filterOrder() &#123; // filter执行顺序，通过数字指定 ,优先级为0，数字越大，优先级越低 return 0; &#125; @Override public boolean shouldFilter() &#123; // 是否执行该过滤器，此处为true，说明需要过滤 return true; &#125; @Override public Object run() throws ZuulException &#123; RequestContext context = RequestContext.getCurrentContext(); HttpServletRequest request = context .getRequest(); // 获取请求的参数 String token = request.getParameter(\"token\"); if (token!=null) &#123; //对请求进行路由 context .setSendZuulResponse(true); context .setResponseStatusCode(200); return null; &#125; else &#123; //不对其进行路由 context .setSendZuulResponse(false); context .setResponseStatusCode(400); context .setResponseBody(\"ERROR\"); return null; &#125; &#125;&#125; 这里我们判断token是否有值，如果没有就抛出error。 下面我们运行看看： 地址：http://localhost:7777/b/hello 地址：http://localhost:7777/b/hello?token=1 地址：http://localhost:9999/hello 这里我们可以看到，如果通过zuul网关去访问你对应的服务，就会触发你的过滤器，如果你是直接访问你对应服务的地址，过滤就不会生效。 而这种网关转发之后的请求 就叫做反向代理你可以隐藏你本地的服务器的真实地址 只暴露给外界网关的地址 然后由网关转发给服务器。","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://xuhao008.github.io/tags/springcloud/"}]},{"title":"什么是微服务，为什么要使用微服务架构","slug":"什么是微服务，为什么要使用微服务架构","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2019/05/31/什么是微服务，为什么要使用微服务架构/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/","excerpt":"前言 最近这几年微服务比较火，很多技术公司对招聘java工程师，都是以有微服务架构开发经验的求职者优先，仿佛不谈点微服务相关的技术，都显得不是那么主流了。 一：什么是微服务 1、 微服务的概念源于2014年3月Martin Fowler所写的一篇文章“Microservices”(http://martinfowler.com/articles/microservices.html)。 2、微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。 3、如果要用比较通俗的解释，我觉得可以用如今手机行业的手机生产制作来形容，如今各个手机厂商每台手机几乎都是各大厂商技术的集合体，就比如一台小米手机，cpu可能来自高通，屏幕来自三星，摄像头来自索尼等等，手机每个部分都由不同厂商提供，强强联合，才能制作一台真正优秀的手机，而微服务就像这样，每个功能点单独完成，最后组成一个强大的项目。 二、为什么使用微服务 提到为什么使用微服务架构就应该先了解一下一体化架构。 1、什么是一体化架构？ 答：一体化架构顾名思义，将应用各层打成一个包来部署。为了让代码正常工作，一体化应用的所有组件缺一不可，各部分高度依赖。比如我们常见的普通web项目，一般分为表现层，业务逻辑层，数据访问层，所有代码都放在一个代码库中，某一层的代码变化都影响整个项目的构建和部署。 2、为什么使用微服务架构 答：微服务架构其实就是一种架构风格，我们将整个项目划分为多个独立的小项目，也就是我们俗称的微服务，但是微服务的“’微”并没有明确的定义，可以理解为每个微服务都单独处理某个功能模块，可以独立开发、测试、部署、监控和扩展，甚至可以用不同的编程语言开发它们。它有利于我们平时项目的开发，解决了一体化架构项目难以扩展，开发周期长，故障级联等问题，这也是微服务近几年越来越流行的一个原因。 三、微服务有什么优缺点 1、优点： 独立开发部署服务 速度和敏捷性 更高的代码质量 获得围绕业务功能创建/组织的代码 改善故障隔离。一个服务宕机不会影响其他的服务 易于规模化开发，多个开发团队可以并行开发，每个团队负责一项服务 更容易扩展 可以使用不同的语言 2、缺点 测试工作更加困难 服务调用跨更多节点，分布式事务数据不一致性可能更大。 部署复杂，成本高 开发人员要处理分布式系统的复杂性，提高了开发的复杂性 服务调用跨网络，增加网络IO，降低性能。","text":"前言 最近这几年微服务比较火，很多技术公司对招聘java工程师，都是以有微服务架构开发经验的求职者优先，仿佛不谈点微服务相关的技术，都显得不是那么主流了。 一：什么是微服务 1、 微服务的概念源于2014年3月Martin Fowler所写的一篇文章“Microservices”(http://martinfowler.com/articles/microservices.html)。 2、微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。 3、如果要用比较通俗的解释，我觉得可以用如今手机行业的手机生产制作来形容，如今各个手机厂商每台手机几乎都是各大厂商技术的集合体，就比如一台小米手机，cpu可能来自高通，屏幕来自三星，摄像头来自索尼等等，手机每个部分都由不同厂商提供，强强联合，才能制作一台真正优秀的手机，而微服务就像这样，每个功能点单独完成，最后组成一个强大的项目。 二、为什么使用微服务 提到为什么使用微服务架构就应该先了解一下一体化架构。 1、什么是一体化架构？ 答：一体化架构顾名思义，将应用各层打成一个包来部署。为了让代码正常工作，一体化应用的所有组件缺一不可，各部分高度依赖。比如我们常见的普通web项目，一般分为表现层，业务逻辑层，数据访问层，所有代码都放在一个代码库中，某一层的代码变化都影响整个项目的构建和部署。 2、为什么使用微服务架构 答：微服务架构其实就是一种架构风格，我们将整个项目划分为多个独立的小项目，也就是我们俗称的微服务，但是微服务的“’微”并没有明确的定义，可以理解为每个微服务都单独处理某个功能模块，可以独立开发、测试、部署、监控和扩展，甚至可以用不同的编程语言开发它们。它有利于我们平时项目的开发，解决了一体化架构项目难以扩展，开发周期长，故障级联等问题，这也是微服务近几年越来越流行的一个原因。 三、微服务有什么优缺点 1、优点： 独立开发部署服务 速度和敏捷性 更高的代码质量 获得围绕业务功能创建/组织的代码 改善故障隔离。一个服务宕机不会影响其他的服务 易于规模化开发，多个开发团队可以并行开发，每个团队负责一项服务 更容易扩展 可以使用不同的语言 2、缺点 测试工作更加困难 服务调用跨更多节点，分布式事务数据不一致性可能更大。 部署复杂，成本高 开发人员要处理分布式系统的复杂性，提高了开发的复杂性 服务调用跨网络，增加网络IO，降低性能。 3、这里也只是简单的列举了一些优缺点，如果要详细了解百度上很多，也很详细。 四、总结： 上面也只是比较简单说了一下微服务，其实无论哪种技术，哪种架构，有优点，也必有缺点，在开发中，这些问题我们其实天天都可以遇到，就比如常用的一些集合类型，效率高的，线程就不一定安全，线程安全的效率也不一定高。技术是死的，但是人是活的，我们只有面对不同情况，选择不同技术，最后才能真正的以最优的方案解决问题。","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://xuhao008.github.io/tags/springcloud/"}]},{"title":"使用docker-compose快速创建个人博客","slug":"使用docker-compose快速创建个人博客","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2019/05/31/使用docker-compose快速创建个人博客/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/%E4%BD%BF%E7%94%A8docker-compose%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"一、安装docker 可以查看下方博客进行安装 https://blog.csdn.net/weixin_44209403/article/details/103232900 二、安装docker-compose 1.从github上下载docker-compose二进制文件安装 下载最新版的docker-compose文件 1sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-uname -s-uname -m -o /usr/local/bin/docker-compose 若是github访问太慢，可以用daocloud下载 1sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-uname -s-uname -m -o /usr/local/bin/docker-compose 添加可执行权限","text":"一、安装docker 可以查看下方博客进行安装 https://blog.csdn.net/weixin_44209403/article/details/103232900 二、安装docker-compose 1.从github上下载docker-compose二进制文件安装 下载最新版的docker-compose文件 1sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-uname -s-uname -m -o /usr/local/bin/docker-compose 若是github访问太慢，可以用daocloud下载 1sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-uname -s-uname -m -o /usr/local/bin/docker-compose 添加可执行权限 1sudo chmod +x /usr/local/bin/docker-compose 测试安装结果 1docker-compose --version 三、导入编写好的yml文件，进行环境和项目搭建 导入如下yml文件 12345678910111213141516171819202122232425262728version: '3.3'services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpressvolumes: db_data: &#123;&#125; 在服务器中创建文件夹，将上方yml文件导入到服务器文件夹中 在该文件夹下输入如下命令，即可快速搭建好博客环境 注意：命令中“docker-compose”是你的yml文件的名称 1docker-compose up -d 最后，输入docker ps，可以查看已经有两个服务启动了 然后在浏览器中输入你的服务器ip和端口8000就可以访问你的博客了 注意：第一次访问需要设置你的用户名和密码，还有邮箱。","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://xuhao008.github.io/tags/docker/"}]},{"title":"linux(CentOS7)安装docker和使用docker教程","slug":"linux(阿里ESC服务器：CentOS 7.6 64位)docker简介和安装docker和使用docker教程","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2019/05/31/linux(阿里ESC服务器：CentOS 7.6 64位)docker简介和安装docker和使用docker教程/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/linux(%E9%98%BF%E9%87%8CESC%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9ACentOS%207.6%2064%E4%BD%8D)docker%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85docker%E5%92%8C%E4%BD%BF%E7%94%A8docker%E6%95%99%E7%A8%8B/","excerpt":"一、什么是Docker 1、Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 2、Docker使用Go语言编写 适用于Linux平台（仅适用） ，但是又能在windows和OS X mac等系统上安装，为什么呢？ 其实docker并没有跨平台，它运行依赖Linux内核，在OS X和windows运行docker会先产生一个Linux虚拟机来运行。 Docker 官网：http://www.docker.com Github Docker 源码：https://github.com/docker/docker 帮助文档:https://docs.docker.com 二、为什么要使用 Docker，Docker有什么作用？ 1、首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数很多个 Docker 容器。 容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销小。 2、DocKer一次构建可放在任何地方就可以运行，不需要进行任何改变DocKer 就类似于一个容器。这个容器就好像咱们常用的虚拟机一样，当我们虚拟机里面安装过VS、SQL、浏览器 … 之后咱们就把虚拟机镜像备份下来、等到下一次需要重新搭一个环境的时候，就可以省去很多事情了，直接把备份的虚拟机运行起来，该有的就都有了，省去了很多事情。 在用DocKer的情况下，咱们可以直接把项目发布在DocKer容器上面进行测试，当项目需要正式上线的时候我们直接可以把做好的DocKer 镜像部署上去就行了，如果测试的好，就不必担心项目上正式版本的时候再出现什么问题了，（比如说 咱们的Confing 配置信息很多项目都是什么测试环境地址，正式环境地址的，但是用过DocKer之后就一个就行了）DocKer可以在 云、Windows、Linux 等环境上进行部署，就单说这一点就省去了我的很多费用、还有项目部署上线的风险,不必每次项目上线都留守一堆人才等着项目报错. 三、安装Docker和使用Docker Cenos7阿里云下载地址：http://mirrors.aliyun.com/centos Docker官网安装说明：https://docs.docker.com/install/linux/docker-ce/centos 1、如果以前安装过旧版本的docker可以删除： yum remove docker 2、可以先升级所有包同时也升级软件和系统内核 yum -y update","text":"一、什么是Docker 1、Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 2、Docker使用Go语言编写 适用于Linux平台（仅适用） ，但是又能在windows和OS X mac等系统上安装，为什么呢？ 其实docker并没有跨平台，它运行依赖Linux内核，在OS X和windows运行docker会先产生一个Linux虚拟机来运行。 Docker 官网：http://www.docker.com Github Docker 源码：https://github.com/docker/docker 帮助文档:https://docs.docker.com 二、为什么要使用 Docker，Docker有什么作用？ 1、首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数很多个 Docker 容器。 容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销小。 2、DocKer一次构建可放在任何地方就可以运行，不需要进行任何改变DocKer 就类似于一个容器。这个容器就好像咱们常用的虚拟机一样，当我们虚拟机里面安装过VS、SQL、浏览器 … 之后咱们就把虚拟机镜像备份下来、等到下一次需要重新搭一个环境的时候，就可以省去很多事情了，直接把备份的虚拟机运行起来，该有的就都有了，省去了很多事情。 在用DocKer的情况下，咱们可以直接把项目发布在DocKer容器上面进行测试，当项目需要正式上线的时候我们直接可以把做好的DocKer 镜像部署上去就行了，如果测试的好，就不必担心项目上正式版本的时候再出现什么问题了，（比如说 咱们的Confing 配置信息很多项目都是什么测试环境地址，正式环境地址的，但是用过DocKer之后就一个就行了）DocKer可以在 云、Windows、Linux 等环境上进行部署，就单说这一点就省去了我的很多费用、还有项目部署上线的风险,不必每次项目上线都留守一堆人才等着项目报错. 三、安装Docker和使用Docker Cenos7阿里云下载地址：http://mirrors.aliyun.com/centos Docker官网安装说明：https://docs.docker.com/install/linux/docker-ce/centos 1、如果以前安装过旧版本的docker可以删除： yum remove docker 2、可以先升级所有包同时也升级软件和系统内核 yum -y update 3、安装docker ​yum install docker 4、查看docker版本，是否安装成功 docker version 5、启动docker，设置开机启动 启动：service docker start 开机启动： systemctl start docker systemctl enable docker 查看状态：service docker status 停止docker：service docker stop 6、 切换镜像仓库地址，由于docker默认的镜像下载地址是国外的地址，下载速度慢，所有我们需要更换，提高下载速度，这里我们使用阿里云的镜像地址 使用命令：vi /etc/docker/daemon.json 找到配置文件修改为下方内容 { “registry-mirrors”: [“https://pee6w651.mirror.aliyuncs.com”] } #使生效 sudo systemctl daemon-reload #重启docker服务 sudo systemctl restart docker 7、查找可用docker镜像，和拉取镜像。 注：docker镜像是以：用户名/镜像名来显示的，如果要拉取需要这样的格式，不过部分镜像可以直接通过镜像名拉取 搜索： docker search 要搜索的镜像名称 拉取：docker pull 镜像名 示例： docker search mysql docker pull mysql 8、查看拉取的所有镜像 docker images 9、创建容器 docker run -di --name 自定义的容器名称 -p 本地主机端口：映射到容器的端口 镜像名称 示例：docker run -di --name myredis 6379:6379 redis 10、如果使用阿里云ESC服务器需要配置安全组策略，开放端口 11、查看所有容器和查看当前运行的容器，启动容器，停止容器，删除容器 查看所有容器：docker ps -a 当前运行容器：docker ps 启动容器：docker start 容器ID(使用docker ps -a可以查看要启动容器的id) 停止容器：docker stop 容器ID 删除容器：docker rm 容器ID(删除容器要先停止当前要删除的容器) 12、进入容器 docker exec -it 容器ID /bin/bash","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://xuhao008.github.io/tags/docker/"}]},{"title":"SpringBoot+Vue+Redis实现单点登录(一处登录，另一处退出登录)","slug":"SpringBoot+Vue+Jpa+Redis实现单点登录(一处登录，另一处退出登录)","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/05/31/SpringBoot+Vue+Jpa+Redis实现单点登录(一处登录，另一处退出登录)/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/SpringBoot+Vue+Jpa+Redis%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95(%E4%B8%80%E5%A4%84%E7%99%BB%E5%BD%95%EF%BC%8C%E5%8F%A6%E4%B8%80%E5%A4%84%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95)/","excerpt":"一、需求 实现用户在浏览器登录后，跳转到其他页面，当用户在其它地方又登录时，前面用户登录的页面退出登录(列如qq挤号那种方式) 二、实现思路 用户在前端填写用户信息登录后，后台接收数据先去数据库进行判断，如果登录成功，创建map集合，以用户id为键，token为值，先通过当前登录用户的id去获取token，如果token存在说明该用户已经登录过，调用redis以token为键删除上个用户的信息，调用方法生成新token，并将token存入map集合，将用户信息存入redis，并将token存入cookie。当用户回到前面登录的页面时，刷新页面，调用方法，通过后端获取cookie的token值，通过token在redis中查询用户信息是否存在，如果不存在，前端通过返回值判断重新回到登录页面！ 三、实现代码 后端： 1、创建SpringBoot项目，创建User表，由于是通过Vue编写的，所以是前后端分离，需要跨域，我这里编写了跨域配置类，还有redis的util类，返回的封装类，cookie的util类，文末有源码提供，可以自行提取。 2、yum配置文件 1234567891011121314151617181920212223spring: redis: database: 0 #redis的默认数据库为0 host: 127.0.0.1 #链接redis的ip port: 6379 #链接redis的端口号 password: #链接redis的密码 默认为空 jedis: pool: max-total: 200 #链接redis的总数目 max-active: 100 #链接redis的最大 max-idle: 8 #最大的链接数量 min-idle: 5 #最小的链接数量 datasource: url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: show-sql: trueserver: port: 8888REDIS_KEY : USER_TOKEN 3、编写实体User.class 123456789101112@Data@Entity@Table(name = \"user\")public class User &#123; @Id @Column(name = \"id\",unique = true,nullable = false) private int id; @Column(name = \"username\",nullable = false) private String username; @Column(name = \"password\",nullable = false) private String password;&#125; 4、编写Dao，UserDao.class","text":"一、需求 实现用户在浏览器登录后，跳转到其他页面，当用户在其它地方又登录时，前面用户登录的页面退出登录(列如qq挤号那种方式) 二、实现思路 用户在前端填写用户信息登录后，后台接收数据先去数据库进行判断，如果登录成功，创建map集合，以用户id为键，token为值，先通过当前登录用户的id去获取token，如果token存在说明该用户已经登录过，调用redis以token为键删除上个用户的信息，调用方法生成新token，并将token存入map集合，将用户信息存入redis，并将token存入cookie。当用户回到前面登录的页面时，刷新页面，调用方法，通过后端获取cookie的token值，通过token在redis中查询用户信息是否存在，如果不存在，前端通过返回值判断重新回到登录页面！ 三、实现代码 后端： 1、创建SpringBoot项目，创建User表，由于是通过Vue编写的，所以是前后端分离，需要跨域，我这里编写了跨域配置类，还有redis的util类，返回的封装类，cookie的util类，文末有源码提供，可以自行提取。 2、yum配置文件 1234567891011121314151617181920212223spring: redis: database: 0 #redis的默认数据库为0 host: 127.0.0.1 #链接redis的ip port: 6379 #链接redis的端口号 password: #链接redis的密码 默认为空 jedis: pool: max-total: 200 #链接redis的总数目 max-active: 100 #链接redis的最大 max-idle: 8 #最大的链接数量 min-idle: 5 #最小的链接数量 datasource: url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: show-sql: trueserver: port: 8888REDIS_KEY : USER_TOKEN 3、编写实体User.class 123456789101112@Data@Entity@Table(name = \"user\")public class User &#123; @Id @Column(name = \"id\",unique = true,nullable = false) private int id; @Column(name = \"username\",nullable = false) private String username; @Column(name = \"password\",nullable = false) private String password;&#125; 4、编写Dao，UserDao.class 123public interface UserDao extends JpaRepository&lt;User,Integer&gt; &#123; public User findByUsernameAndPassword(String username, String password);&#125; 5、编写serviceImpl,UserServiceImpl.class进行登录的业务逻辑处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Servicepublic class UserServiceImpl&#123; @Autowired private UserDao userDao; @Autowired private JedisDao jedisDao; @Value(\"$&#123;REDIS_KEY&#125;\") //从配置文件中取值 private String KEY; private Map&lt;Integer,String&gt; UserLogin = new HashMap&lt;&gt;(); /** * 登录 * @param request * @param response * @param u * @return */ public User userlogin(HttpServletRequest request, HttpServletResponse response, User u)&#123; //查询登录是否成功 User user=userDao.findByUsernameAndPassword(u.getUsername(),u.getPassword()); //判断us是否为空 if(user==null)&#123; return null; &#125; //生成token String token=\"user_\"+ UUID.randomUUID().toString(); //从map中获得redis中的key String oldToken = UserLogin.get(user.getId()); //判断map中是否存在该id if(!StringUtils.isEmpty(oldToken))&#123; //删除redis中老的值 jedisDao.delValue(oldToken); &#125; //将新的的key保存到map中 UserLogin.put(user.getId(),token); //将信息存入redis jedisDao.setValue(token, JsonUtils.objectToJson(user)); //将token放入cookie中 CookieUtils.setCookie(request,response,KEY,token,5*60,true); return user; &#125; /** * 判断是否登录 * @param response * @param request * @return */ public String getUserByToken(HttpServletResponse response, HttpServletRequest request) &#123; //从cookie中取出用户token String token=CookieUtils.getCookieValue(request,KEY); //从redis中取出用户信息 String user= jedisDao.getValue(token); return user; &#125;&#125; 6、编写controller，接收前端请求，返回数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@RestControllerpublic class LoginController &#123; @Autowired private UserServiceImpl userService; /** * 登录 * @param response * @param request * @param user * @param model * @return */ @PostMapping(\"/login\") public ResponseResult Login(HttpServletResponse response , HttpServletRequest request, @RequestBody User user, Model model)&#123; ResponseResult responseResult=new ResponseResult(); try &#123; User user2 = userService.userlogin(request, response, user); if (user2!=null)&#123; responseResult.setState(200); responseResult.setMsg(\"登录成功！\"); return responseResult; &#125;else&#123; responseResult.setState(202); responseResult.setMsg(\"用户名或密码错误！\"); return responseResult; &#125; &#125;catch (Exception e) &#123; responseResult.setState(500); responseResult.setMsg(\"发生错误，登录失败！\"); return responseResult; &#125; &#125; /** * 判断是否登录 * @param response * @param request * @return * @throws Exception */ @GetMapping(\"/toLogin\") public ResponseResult getUserInfo(HttpServletResponse response , HttpServletRequest request) throws Exception &#123; ResponseResult responseResult=new ResponseResult(); try&#123; String token = userService.getUserByToken(response, request); if(token!=null)&#123; responseResult.setState(200); responseResult.setMsg(\"登录中！\"); return responseResult; &#125;else&#123; responseResult.setState(202); responseResult.setMsg(\"在别处登录！\"); return responseResult; &#125; &#125;catch (Exception e)&#123; response.setStatus(500); responseResult.setMsg(\"发生错误！\"); return responseResult; &#125; &#125;&#125; Vue前端 1、创建Vue项目：vue init webpack 项目名称 2、引入axios：npm install --save axios vue-axios 3、引入element：npm i element-ui -S 4、在src的main.js下配置 12345678910import axios from 'axios'import VueAxios from 'vue-axios'// element-ui 引入文件import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'//注册 VueAxios, axiosVue.use(VueAxios, axios)Vue.use(ElementUI)//配置axios支持cookieaxios.defaults.withCredentials = true; 5、在src的components下创建login.vue,userinfo.vue,并在src的router下配置访问地址 1234567891011121314151617import Vue from 'vue'import Router from 'vue-router'import login from '@/components/login'import UserInfo from '@/components/userinfo'Vue.use(Router)export default new Router(&#123; routes: [&#123; path: '/login', component: login &#125;, &#123; path: '/user_info', component: UserInfo &#125;]&#125;) 6、前端的代码这里就不贴出了，代码是有详细的注释，请自行下载代码查看 四、代码地址和演示效果 登录： 下线： dome代码地址 链接：https://pan.baidu.com/s/1qm5uktPJAT6pB4SI37s5Vw 提取码：e5hn 该dome仅供参考，如果有什么错误希望可以及时留言指出，谢谢！","categories":[],"tags":[{"name":"单点登录","slug":"单点登录","permalink":"http://xuhao008.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"}]},{"title":"SpringBoot+elasticsearch实现全文检索，做一个简单的搜索引擎","slug":"SpringBoot+elasticsearch实现全文检索，做一个简单的搜索引擎","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/05/31/SpringBoot+elasticsearch实现全文检索，做一个简单的搜索引擎/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/SpringBoot+elasticsearch%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%EF%BC%8C%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/","excerpt":"一、什么是elasticsearch 答：“ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。” 二、配置Elasticsearch和logstash https://blog.csdn.net/fjyab/article/details/81101284 https://blog.csdn.net/wzn1054162229/article/details/101480921 注：上方博客可能配置方式不同，请自行参照。其中配置logstash将数据库数据导入到Elasticsearch中时，如果运行不能连接，那么数据库连接JAR包请放到下方路径下: 三、后台代码编写 1、创建SpringBoot项目，通过spring boot操作elasticsearch需要通过spring data elasticsearch来实现 2、导入依赖，和yml配置 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 123456789server: port: 8888spring: data: elasticsearch: cluster-name: es cluster-nodes: 127.0.0.1:9300 jackson: default-property-inclusion: non_null 3、编写实体类：Goods .java","text":"一、什么是elasticsearch 答：“ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。” 二、配置Elasticsearch和logstash https://blog.csdn.net/fjyab/article/details/81101284 https://blog.csdn.net/wzn1054162229/article/details/101480921 注：上方博客可能配置方式不同，请自行参照。其中配置logstash将数据库数据导入到Elasticsearch中时，如果运行不能连接，那么数据库连接JAR包请放到下方路径下: 三、后台代码编写 1、创建SpringBoot项目，通过spring boot操作elasticsearch需要通过spring data elasticsearch来实现 2、导入依赖，和yml配置 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 123456789server: port: 8888spring: data: elasticsearch: cluster-name: es cluster-nodes: 127.0.0.1:9300 jackson: default-property-inclusion: non_null 3、编写实体类：Goods .java 123456789101112@Data@Document(indexName = \"goodscat\", type = \"docs\", shards = 1, replicas = 0)//选中elasticsearch索引public class Goods &#123; private Long cid; private String name; private String isParent; private String parentId; private Long level; private String pathid;&#125; 4、编写repository层，创建GoodsRepository.java,继承ElasticsearchRepository 123public interface GoodsRepository extends ElasticsearchRepository&lt;Goods,Long&gt; &#123;&#125; 5、编写service和serviceImpl 123public interface SearchService &#123; PageResult&lt;Goods&gt; search(SearchRequest request);&#125; 12345678910111213141516171819202122232425262728293031@Slf4j@Servicepublic class SearchServiceImpl implements SearchService &#123; @Autowired private GoodsRepository goodsRepository; @Autowired private ElasticsearchTemplate template; @Override public PageResult&lt;Goods&gt; search(SearchRequest request) &#123; int page = request.getPage() - 1; int size = request.getSize(); //创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;\"cid\", \"name\"&#125;, null)); //分页 queryBuilder.withPageable(PageRequest.of(page, size)); //过滤 queryBuilder.withQuery(QueryBuilders.matchQuery(\"name\", request.getKey())); //查询 AggregatedPage&lt;Goods&gt; result = template.queryForPage(queryBuilder.build(), Goods.class); //解析结果 //分页结果解析 long total = result.getTotalElements(); Integer totalPages1 = result.getTotalPages(); //失效 Long totalPages = total % size == 0 ? total / size : total / size + 1; List&lt;Goods&gt; goodsList = result.getContent(); //解析聚合结果 return new PageResult(total, totalPages, goodsList); &#125;&#125; 6、编写分页工具类 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125;&#125; 6、编写controller 123456789101112131415@RestControllerpublic class SearchController &#123; @Autowired private SearchService searchService; /** * 搜索功能 * @param request * @return */ @GetMapping(\"search\") public ResponseEntity&lt;PageResult&lt;Goods&gt;&gt; search(SearchRequest request) &#123; return ResponseEntity.ok(searchService.search(request)); &#125;&#125; 7、编写一个搜索条件接收类，用来接收前台搜索条件，和分页条件 12345678910111213141516171819202122232425public class SearchRequest &#123; private String key;// 搜索条件 private Integer page;// 当前页 private static final Integer DEFAULT_SIZE = 10;// 每页大小，不从页面接收，而是固定大小 private static final Integer DEFAULT_PAGE = 1;// 默认页 public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Integer getPage() &#123; if(page == null)&#123; return DEFAULT_PAGE; &#125; // 获取页码时做一些校验，不能小于1 return Math.max(DEFAULT_PAGE, page); &#125; public void setPage(Integer page) &#123; this.page = page; &#125; public Integer getSize() &#123; return DEFAULT_SIZE; &#125;&#125; 8、返回的json数据格式 123456789101112131415161718&#123; \"total\": 3, \"totalPage\": 1, \"items\": [ &#123; \"cid\": 50010363, \"name\": \"许愿瓶/幸运星瓶\" &#125;, &#123; \"cid\": 70000558, \"name\": \"英国特许公认会计师ACCA\" &#125;, &#123; \"cid\": 50004583, \"name\": \"英国特许公认会计师ACCA\" &#125; ]&#125; 四、Vue+Element前端编写 1、创建vue项目 2、安装 axios 插件，在当前项目下的终端输入命令: ==npm install --save axios vue-axios== 安装 Element 插件，在当前项目下的终端输入命令:==npm i element-ui -S== 3、在 src 文件夹下的程序入口 main.js 中导入 12345678import axios from 'axios'import VueAxios from 'vue-axios'// element-ui 引入文件import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';//注册 VueAxios, axiosVue.use(VueAxios, axios)Vue.use(ElementUI) 4、导入template，编写静态页面，并绑定下方方法和属性 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;!-- 上方搜索框，和下拉即时搜索 --&gt; &lt;el-autocomplete v-model=\"state\" :fetch-suggestions=\"querySearchAsync\" placeholder=\"请输入内容\" @select=\"handleSelect\" select-when-unmatched=\"true\" :debounce=\"0\" &gt;&lt;/el-autocomplete&gt; &lt;el-button slot=\"append\" icon=\"el-icon-search\" @click=\"onSubmit\"&gt;&lt;/el-button&gt;&lt;!-- 下方搜索结果显示 --&gt; &lt;div class=\"div2\" v-show=\"con\"&gt; &lt;p style=\"font-size:22px\"&gt; 搜索 &lt;span style=\"color: #F08080\"&gt;&#123;&#123;state&#125;&#125;&lt;/span&gt;的结果（总共搜索到 &lt;span style=\"color: #F08080\"&gt;&#123;&#123;total&#125;&#125;&lt;/span&gt;条记录） &lt;/p&gt; &lt;p v-for=\"entity in All\" class=\"p2\"&gt; &lt;a href=\"http://www.baidu.com\"&gt;&#123;&#123;entity.name&#125;&#125;&lt;/a&gt; &lt;/p&gt; &lt;!-- 分页组件 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :total=\"total\" :page-size=\"15\" @current-change=\"handleCurrentChange\" :current-page=\"page\" &gt;&lt;/el-pagination&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 注：其中显示搜索内容的p标签，因为绑定了v-for和element产生了冲突，会报错，但是不影响效果，请忽略 5、编写各部分js代码，定义属性，方法，请求。各方法属性有注释，请认真查看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script&gt;//导入axios，进行ajax访问const axios = require(\"axios\");export default &#123; data () &#123; return &#123; con: false,//控制下方显示框，隐藏或显示 restaurants: [],//即时搜索，下拉框信息 state: '',//搜索条件 timeout: null, All: [],//下方显示框数据集合 total: 0, //搜索返回的总结果数量 page: 1,//分页的当前页数 &#125;; &#125;, watch: &#123; state: &#123; // 监视字段，页数 handler () &#123; if (this.state.length &gt; 0) &#123;//如果有搜索条件 this.restaurants = [];//先清空即时搜索集合数据 this.loadAll();//查询 &#125; else &#123; this.con = false;//没有搜索条件，隐藏下方数据显示窗口 this.restaurants = []; this.All = [];//并清空结果集合 this.page = 1;//分页归一 &#125; &#125; &#125;, page: &#123; // 监视字段，页数 handler () &#123; this.loadAll();//如果页面发生变化，就查询新的页面的数据 &#125; &#125; &#125;, methods: &#123; //分页是上下页，触发的方法 handleCurrentChange (val) &#123;//当前页 this.page = val; console.log(`当前页: $&#123;val&#125;`); &#125;, loadAll () &#123; var app = this; axios.get(\"http://localhost:8888/search\", &#123; params: &#123; 'key': app.state,//搜索条件 'page': app.page//当前第几页 &#125; &#125;).then(function (resp) &#123; app.total = resp.data.total;//当前数据一共有多少条 var rs = resp.data.items; app.All = rs;//给显示结果的集合赋值 if (rs.length &gt; 0) &#123; for (var i = 0; i &lt; 10; i++) &#123;//只显示10条提示 app.restaurants[i] = &#123; value: rs[i].name, cid: rs[i].cid &#125;//给及时搜索下拉框赋值 &#125; &#125; &#125;).catch(function (error) &#123; console.log(error); &#125;); &#125;, querySearchAsync (queryString, cb) &#123;//加载即时搜索条件 var results = this.restaurants; clearTimeout(this.timeout); this.timeout = setTimeout(() =&gt; &#123; cb(results); &#125;, 1000 * Math.random()); &#125;, handleSelect (item) &#123;//选中下拉提示的数据时触发 if (this.All != \"\") &#123; this.con = true;//显示结果 &#125; &#125;, onSubmit () &#123; if (this.All != \"\") &#123;//点击查询图标时，显示结果 this.con = true; &#125; &#125; &#125;,&#125;;&lt;/script&gt; 6、编写style样式 12345678910111213141516171819202122&lt;style&gt;.el-autocomplete &#123; width: 400px;&#125;.p2 &#123; margin-left: 160px; text-align: left; font-size: 20px;&#125;a &#123; color: #4f5a75;&#125;.div2 &#123; /* background: blue; */ margin-top: 25px; padding-top: 25px; margin-left: 270px; width: 750px; height: 600px; border: 1px solid #b0c4de;&#125;&lt;/style&gt; 五、演示效果 1、即时搜索 2、搜索结果分页显示 六、项目dome源码和sql文件 链接：https://pan.baidu.com/s/190d0nQhFQ-ZIS1dcAqdNig 提取码：tbp5","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://xuhao008.github.io/tags/elasticsearch/"}]},{"title":"SpringBoot项目实现高并发商品秒杀","slug":"SpringBoot项目实现高并发商品秒杀","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/05/31/SpringBoot项目实现高并发商品秒杀/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/SpringBoot%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E5%95%86%E5%93%81%E7%A7%92%E6%9D%80/","excerpt":"SpringBoot项目实现高并发商品秒杀 注：该项目使用IDEA+SpringBoot+Maven+Mybatis+Redis+RabbitMQ 等技术实现。本人水平有限，以下代码可能有错误，或者解释不清，希望理解，并且及时下方留言，及时修改，谢谢各位道友！ 一、秒杀实现思路 秒杀其实就是一件商品，在某一个时间段内，由于降低了价格，超高的优惠，导致在这一个时间段内购买量大量增加，但是库存有限，产生的一种高并发现象。 秒杀最重要的就是减库存，增订单。同时需要判断用户是否多次秒杀，同时还要防止用户通过恶意软件刷单。 所以需要以下3点： 1、高可用：保证系统的高可用和正确性，设计PlanB备用。 2、一致性：保证秒杀减库存中的数据一致性。 3、高性能：涉及大量并发读写，所以需要支持高并发，从动静分离、热点发现与隔离、请求削峰与分层过滤、服务端极致优化来实现。 具体流程：系统初始化，把商品库存数量等加载到Redis中，用户登录时将用户信息保存到Seesion中，保证用户信息的完整，精确，当用户发送秒杀请求时，判断用户是否已秒杀过，同时前端给用户验证码等判断，将各用户请求时间分开，当确定用户验证通过时，判断库存是否足够，如果不够直接返回请求失败，避免系统压力，如果足够就减库存，Redis预减库存，同时将秒杀请求发送给RabbitMQ ，同时给前端返回状态，显示排队中等状态，同时前端给一个定时根据该商品id去循环请求，后端RabbitMQ监听到消息，就开始操作数据库，修改数据库商品库存和新增订单等操作，前端循环请求返回状态，得到订单代表秒杀成功，或者队列中，否则秒杀失败，秒杀成功后，用户需要在一定时间内付款，不然就自动取消订单，返回库存。 二、部分代码实现 Redis安装教程：https://www.runoob.com/redis/redis-install.html RabbitMQ安装教程：https://www.linuxprobe.com/install-rabbitmq-on-centos-7.html 1、pom文件和xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ljs&lt;/groupId&gt; &lt;artifactId&gt;miaosha_idea&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;miaosha_idea&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 打war包插件 --&gt; &lt;!-- &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; --&gt; &lt;!-- 打jar包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;","text":"SpringBoot项目实现高并发商品秒杀 注：该项目使用IDEA+SpringBoot+Maven+Mybatis+Redis+RabbitMQ 等技术实现。本人水平有限，以下代码可能有错误，或者解释不清，希望理解，并且及时下方留言，及时修改，谢谢各位道友！ 一、秒杀实现思路 秒杀其实就是一件商品，在某一个时间段内，由于降低了价格，超高的优惠，导致在这一个时间段内购买量大量增加，但是库存有限，产生的一种高并发现象。 秒杀最重要的就是减库存，增订单。同时需要判断用户是否多次秒杀，同时还要防止用户通过恶意软件刷单。 所以需要以下3点： 1、高可用：保证系统的高可用和正确性，设计PlanB备用。 2、一致性：保证秒杀减库存中的数据一致性。 3、高性能：涉及大量并发读写，所以需要支持高并发，从动静分离、热点发现与隔离、请求削峰与分层过滤、服务端极致优化来实现。 具体流程：系统初始化，把商品库存数量等加载到Redis中，用户登录时将用户信息保存到Seesion中，保证用户信息的完整，精确，当用户发送秒杀请求时，判断用户是否已秒杀过，同时前端给用户验证码等判断，将各用户请求时间分开，当确定用户验证通过时，判断库存是否足够，如果不够直接返回请求失败，避免系统压力，如果足够就减库存，Redis预减库存，同时将秒杀请求发送给RabbitMQ ，同时给前端返回状态，显示排队中等状态，同时前端给一个定时根据该商品id去循环请求，后端RabbitMQ监听到消息，就开始操作数据库，修改数据库商品库存和新增订单等操作，前端循环请求返回状态，得到订单代表秒杀成功，或者队列中，否则秒杀失败，秒杀成功后，用户需要在一定时间内付款，不然就自动取消订单，返回库存。 二、部分代码实现 Redis安装教程：https://www.runoob.com/redis/redis-install.html RabbitMQ安装教程：https://www.linuxprobe.com/install-rabbitmq-on-centos-7.html 1、pom文件和xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ljs&lt;/groupId&gt; &lt;artifactId&gt;miaosha_idea&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;miaosha_idea&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 打war包插件 --&gt; &lt;!-- &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; --&gt; &lt;!-- 打jar包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; yml配置：主要配置了thymeleaf，redis，RabbitMQ，数据库的一些配置，注意redis，RabbitMQ和数据库的端口，ip和用户名，密码，避免错误。 #thymeleaf spring.thymeleaf.cache=false spring.thymeleaf.content-type=text/html spring.thymeleaf.enabled=true spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.mode=HTML5 #拼接前缀与后缀,去创建templates目录，里面放置模板文件 spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html #mybatis #是否打印sql语句 #spring.jpa.show-sql= true mybatis.type-aliases-package=com.ljs.miaosha.domain #mybatis.type-handlers-package=com.example.typehandler #下划线转换为驼峰 mybatis.configuration.map-underscore-to-camel-case=true mybatis.configuration.default-fetch-size=100 #ms --3000ms—&gt;3s mybatis.configuration.default-statement-timeout=3000 #mybatis配置文件路径 #mapperLocaitons mybatis.mapper-locaitons=classpath:com/ljs/miaosha/dao/*.xml #druid spring.datasource.url=jdbc:mysql://localhost/miaosha?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.filters=stat spring.datasource.initialSize=100 spring.datasource.minIdle=500 spring.datasource.maxActive=1000 spring.datasource.maxWait=60000 spring.datasource.timeBetweenEvictionRunsMillis=60000 spring.datasource.minEvictableIdleTimeMillis=30000 spring.datasource.validationQuery=select ‘x’ spring.datasource.testWhileIdle=true spring.datasource.testOnBorrow=false spring.datasource.testOnReturn=false spring.datasource.poolPreparedStatements=true spring.datasource.maxPoolPreparedStatementPerConnectionSize=20 #redis 配置服务器等信息 redis.host=127.0.0.1 redis.port=6379 redis.timeout=10 #redis.password=123456 redis.poolMaxTotal=1000 redis.poolMaxldle=500 redis.poolMaxWait=500 #static 静态资源配置，设置静态文件路径css,js,图片等等 #spring.mvc.static-path-pattern=/static/** spring.mvc.static-path-pattern=/** spring.resources.add-mappings=true spring.resources.cache-period=3600 spring.resources.chain.cache=true spring.resources.chain.enabled=true spring.resources.chain.gzipped=true spring.resources.chain.html-application-cache=true spring.resources.static-locations=classpath:/static/ #RabbitMQ配置 spring.rabbitmq.host=106.14.252.156 spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=StrongPassword spring.rabbitmq.virtual-host=/ #消费者数量 spring.rabbitmq.listener.simple.concurrency=10 #消费者最大数量 spring.rabbitmq.listener.simple.max-concurrency=10 #消费，每次从队列中取多少个,取多了，可能处理不过来 spring.rabbitmq.listener.simple.prefetch=1 spring.rabbitmq.listener.auto-startup=true #消费失败的数据重新压入队列 spring.rabbitmq.listener.simple.default-requeue-rejected=true #发送,队列满的时候，发送不进去，启动重置 spring.rabbitmq.template.retry.enabled=true #一秒钟之后重试 spring.rabbitmq.template.retry.initial-interval=1000 spring.rabbitmq.template.retry.max-attempts=3 #最大间隔 10s spring.rabbitmq.template.retry.max-interval=10000 spring.rabbitmq.template.retry.multiplier=1.0 2、各部分接口 2_1登录接口 1234567891011@RequestMapping(\"/do_login\")//作为异步操作 @ResponseBody public Result&lt;Boolean&gt; doLogin(HttpServletResponse response,@Valid LoginVo loginVo) &#123;//0代表成功 //参数检验成功之后，登录 CodeMsg cm=miaoshaUserService.login(response,loginVo); if(cm.getCode()==0) &#123; return Result.success(true); &#125;else &#123; return Result.error(cm); &#125; &#125; 2_2、页面缓存接口，返回秒杀商品集合信息， 做页面缓存的list页面，防止同一时间访问量巨大到达数据库，如果缓存时间过长，数据及时性就不高。 12345678910111213141516171819202122232425@RequestMapping(value=\"/to_list\",produces=\"text/html\") @ResponseBody public String toListCache(Model model,MiaoshaUser user,HttpServletRequest request, HttpServletResponse response) &#123; // 1.取缓存 // public &lt;T&gt; T get(KeyPrefix prefix,String key,Class&lt;T&gt; data) String html = redisService.get(GoodsKey.getGoodsList, \"\", String.class); if (!StringUtils.isEmpty(html)) &#123; return html; &#125; model.addAttribute(\"user\", user); //查询商品列表 List&lt;GoodsVo&gt; goodsList= goodsService.getGoodsVoList(); model.addAttribute(\"goodsList\", goodsList); //2.手动渲染 使用模板引擎 templateName:模板名称 String templateName=\"goods_list\"; SpringWebContext context=new SpringWebContext(request,response,request.getServletContext(), request.getLocale(),model.asMap(),applicationContext); html=thymeleafViewResolver.getTemplateEngine().process(\"goods_list\", context); //保存至缓存 if(!StringUtils.isEmpty(html)) &#123; redisService.set(GoodsKey.getGoodsList, \"\", html);//key---GoodsKey:gl---缓存goodslist这个页面 &#125; return html; &#125; 2_3、秒杀商品详情页加载接口，当访问商品详情页时，触发该接口，获取商品详情页信息，并且得到秒杀商品当前时间状态 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(value=\"/detail/&#123;goodsId&#125;\") @ResponseBody public Result&lt;GoodsDetailVo&gt; toDetail_staticPage(Model model, MiaoshaUser user, HttpServletRequest request, HttpServletResponse response, @PathVariable(\"goodsId\")long goodsId) &#123;//id一般用snowflake算法 System.out.println(\"页面静态化/detail/&#123;goodsId&#125;\"); model.addAttribute(\"user\", user); GoodsVo goodsVo=goodsService.getGoodsVoByGoodsId(goodsId); model.addAttribute(\"goods\", goodsVo); //既然是秒杀，还要传入秒杀开始时间，结束时间等信息 long start=goodsVo.getStartDate().getTime(); long end=goodsVo.getEndDate().getTime(); long now=System.currentTimeMillis(); //秒杀状态量 int status=0; //开始时间倒计时 int remailSeconds=0; //查看当前秒杀状态 if(now&lt;start) &#123;//秒杀还未开始，---&gt;倒计时 status=0; remailSeconds=(int) ((start-now)/1000); //毫秒转为秒 &#125;else if(now&gt;end)&#123; //秒杀已经结束 status=2; remailSeconds=-1; //毫秒转为秒 &#125;else &#123;//秒杀正在进行 status=1; remailSeconds=0; //毫秒转为秒 &#125; model.addAttribute(\"status\", status); model.addAttribute(\"remailSeconds\", remailSeconds); GoodsDetailVo gdVo=new GoodsDetailVo(); gdVo.setGoodsVo(goodsVo); gdVo.setStatus(status); gdVo.setRemailSeconds(remailSeconds); gdVo.setUser(user); //将数据填进去，传至页面 return Result.success(gdVo); &#125; 2_4、获取秒杀的path接口，获取地址，并且验证验证码的值是否正确 12345678910111213141516171819202122232425262728293031323334@RequestMapping(value =\"/getPath\") @ResponseBody public Result&lt;String&gt; getMiaoshaPath(HttpServletRequest request,Model model,MiaoshaUser user, @RequestParam(\"goodsId\") Long goodsId, @RequestParam(value=\"vertifyCode\",defaultValue=\"0\") int vertifyCode) &#123; model.addAttribute(\"user\", user); //如果用户为空，则返回至登录页面 if(user==null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //限制访问次数 String uri=request.getRequestURI(); String key=uri+\"_\"+user.getId(); //限定key5s之内只能访问5次 Integer count=redisService.get(AccessKey.access, key, Integer.class); if(count==null) &#123; redisService.set(AccessKey.access, key, 1); &#125;else if(count&lt;5) &#123; redisService.incr(AccessKey.access, key); &#125;else &#123;//超过5次 return Result.error(CodeMsg.ACCESS_LIMIT); &#125; //验证验证码 boolean check=miaoshaService.checkVCode(user, goodsId,vertifyCode ); if(!check) &#123; return Result.error(CodeMsg.REQUEST_ILLEAGAL); &#125; System.out.println(\"通过!\"); //生成一个随机串 String path=miaoshaService.createMiaoshaPath(user,goodsId); System.out.println(\"@MiaoshaController-tomiaoshaPath-path:\"+path); return Result.success(path); &#125; 2_5、订单和消息队列接口 12345678910111213141516171819202122232425262728293031323334@RequestMapping(value=\"/&#123;path&#125;/do_miaosha_ajaxcache\",method=RequestMethod.POST)@ResponseBodypublic Result&lt;Integer&gt; doMiaoshaCache(Model model,MiaoshaUser user, @RequestParam(value=\"goodsId\",defaultValue=\"0\") long goodsId, @PathVariable(\"path\")String path) &#123; model.addAttribute(\"user\", user); //1.如果用户为空，则返回至登录页面 if(user==null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证path,去redis里面取出来然后验证。 boolean check=miaoshaService.checkPath(user,goodsId,path); if(!check) &#123; return Result.error(CodeMsg.REQUEST_ILLEAGAL); &#125; //2.预减少库存，减少redis里面的库存 long stock=redisService.decr(GoodsKey.getMiaoshaGoodsStock,\"\"+goodsId); //3.判断减少数量1之后的stock，区别于查数据库时候的stock&lt;=0 if(stock&lt;0) &#123; return Result.error(CodeMsg.MIAOSHA_OVER_ERROR); &#125; //4.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品 MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndCoodsId(user.getId(), goodsId); if (order != null) &#123;// 重复下单 return Result.error(CodeMsg.REPEATE_MIAOSHA); &#125; //5.正常请求，入队，发送一个秒杀message到队列里面去，入队之后客户端应该进行轮询。 MiaoshaMessage mms=new MiaoshaMessage(); mms.setUser(user); mms.setGoodsId(goodsId); mQSender.sendMiaoshaMessage(mms); //返回0代表排队中 return Result.success(0);&#125; 2_6、秒杀轮询接口，判断用户秒杀是否成功，返回状态 12345678@RequestMapping(value = \"/result\", method = RequestMethod.GET)@ResponseBodypublic Result&lt;Long&gt; doMiaoshaResult(Model model, MiaoshaUser user, @RequestParam(value = \"goodsId\", defaultValue = \"0\") long goodsId) &#123; long result=miaoshaService.getMiaoshaResult(user.getId(),goodsId); System.out.println(\"轮询 result：\"+result); return Result.success(result);&#125; 2_7、订单判断接口，判断订单是否存在，返回订单页面消息，开始支付 12345678910111213141516171819@RequestMapping(\"/detail\") @ResponseBody public Result&lt;OrderDetailVo&gt; info(Model model, MiaoshaUser user, @RequestParam(\"orderId\") long orderId) &#123; if(user==null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; OrderInfo order=orderService.getOrderByOrderId(orderId); if(order==null) &#123; return Result.error(CodeMsg.ORDER_NOT_EXIST); &#125; //订单存在的情况 long goodsId=order.getGoodsId(); GoodsVo gVo=goodsService.getGoodsVoByGoodsId(goodsId); OrderDetailVo oVo=new OrderDetailVo(); oVo.setGoodsVo(gVo); oVo.setOrder(order); return Result.success(oVo);//返回页面login &#125; 三、项目资料等 1、由于代码过多，这里就不全部贴出了 2、项目代码 链接：https://pan.baidu.com/s/1qZjAuce1gRRXHHDHZgDLmw 提取码：iroz 3、该秒杀项目的视频，来源慕课网 https://www.imooc.com 链接：https://pan.baidu.com/s/1vjBlJ82iiIjBSkEN9hbEsA 提取码：33qx 4、借鉴了部分博主的博客，非常感谢 https://blog.csdn.net/Brad_PiTt7/article/details/90717429","categories":[],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://xuhao008.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"SpringDataJpa+vue+Echarts绘制柱状图和饼状图","slug":"SpringDataJpa+vue+Echarts绘制柱状图和饼状图","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/05/31/SpringDataJpa+vue+Echarts绘制柱状图和饼状图/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/SpringDataJpa+vue+Echarts%E7%BB%98%E5%88%B6%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%92%8C%E9%A5%BC%E7%8A%B6%E5%9B%BE/","excerpt":"注明：dome源码和sql文末自取。该dome使用了IDEA和vs-code编码工具。idea使用了lombok插件。 一、后端实现 1、创建SpringBoot项目，勾选 web、jpa、lombok、mysql、jdbc 启动器，并创建对应的层 2、创建Charts.java实体类 1234567891011121314@Data@Entity@Table(name = \"charts\")public class Charts &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) @JsonIgnore private Integer id; @Column(name = \"name\",nullable = false,length = 50) private String name; @Column(name = \"num\",nullable = false,length = 50) private String num;&#125; 3、编写dao层，ChartsDao .java接口类，继承JpaRepository接口(不了解可点击查看说明) 12public interface ChartsDao extends JpaRepository&lt;Charts,Integer&gt; &#123;&#125; 4、编写service层，ChartsService.java 1234567891011@Service@Transactionalpublic class ChartsService &#123; @Autowired private ChartsDao chartsDao; public List&lt;Charts&gt; findAll()&#123; return chartsDao.findAll(); &#125;&#125; 6、编写controller层，ChartsController.java,调用servicefindAll方法，查询所有信息 1234567891011@RestControllerpublic class ChartsController &#123; @Autowired private ChartsService chartsService; @GetMapping(\"findAll\") public List&lt;Charts&gt; findAll()&#123; return chartsService.findAll(); &#125;&#125;","text":"注明：dome源码和sql文末自取。该dome使用了IDEA和vs-code编码工具。idea使用了lombok插件。 一、后端实现 1、创建SpringBoot项目，勾选 web、jpa、lombok、mysql、jdbc 启动器，并创建对应的层 2、创建Charts.java实体类 1234567891011121314@Data@Entity@Table(name = \"charts\")public class Charts &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) @JsonIgnore private Integer id; @Column(name = \"name\",nullable = false,length = 50) private String name; @Column(name = \"num\",nullable = false,length = 50) private String num;&#125; 3、编写dao层，ChartsDao .java接口类，继承JpaRepository接口(不了解可点击查看说明) 12public interface ChartsDao extends JpaRepository&lt;Charts,Integer&gt; &#123;&#125; 4、编写service层，ChartsService.java 1234567891011@Service@Transactionalpublic class ChartsService &#123; @Autowired private ChartsDao chartsDao; public List&lt;Charts&gt; findAll()&#123; return chartsDao.findAll(); &#125;&#125; 6、编写controller层，ChartsController.java,调用servicefindAll方法，查询所有信息 1234567891011@RestControllerpublic class ChartsController &#123; @Autowired private ChartsService chartsService; @GetMapping(\"findAll\") public List&lt;Charts&gt; findAll()&#123; return chartsService.findAll(); &#125;&#125; 7、由于是前后端分离，需要跨域，我这里配置了一个配置类，实现跨域请求 123456789101112131415161718192021222324252627282930313233@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); //1.添加CORS配置信息 final CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.setAllowCredentials(true); config.addAllowedHeader(\"*\"); config.addAllowedOrigin(\"*\"); config.addAllowedMethod(\"*\"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"HEAD\"); config.addAllowedMethod(\"GET\"); config.addAllowedMethod(\"PUT\"); config.addAllowedMethod(\"POST\"); config.addAllowedMethod(\"DELETE\"); config.addAllowedMethod(\"PATCH\"); // 4）允许的头信息 config.addAllowedHeader(\"*\"); //5,有效时长 config.setMaxAge(3600L); //2.添加映射路径，我们拦截一切请求 final UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 8、请求返回的部分json数据格式 [ { “name”: “java”, “num”: “200” }, { “name”: “c”, “num”: “150” }, { “name”: “c++”, “num”: “100” }, { “name”: “pathon”, “num”: “100” } ] 二、编写vue+Echarts实现柱状图和饼状图 1、创建vue项目： vue init webpack 项目名称， 导入 axios 插件：npm install --save axios vue-axios 导入v-charts:npm install echarts v-charts --save-dev(v-charts是Echarts的封装，详情可点击查看) 2、在src的main.js下导入插件 123456import axios from 'axios'import VueAxios from 'vue-axios'import VCharts from 'v-charts'Vue.use(VCharts)//注册 VueAxios, axiosVue.use(VueAxios, axios) 3、在config下的index.js下进行跨域配置 12345678910proxyTable: &#123; // 表示以后以/userapi 开头的请求，代理请求 http://localhost:8080 '/userapi': &#123; target: 'http://localhost:8888', //后端接口地址 changeOrigin: true, //是否允许跨越 pathRewrite: &#123; '^/userapi': '', //重写, &#125; &#125; &#125;, 4、创建vue文件，编写柱状图 4_1、编写柱状图template 123&lt;template&gt; &lt;ve-histogram :data=\"chartData\" :title=\"chartTitle\" :settings=\"chartSettings\" :extend=\"extend\"&gt;&lt;/ve-histogram&gt;&lt;/template&gt; 4_2、在data中配置各种显示数据和样式，代码中有详细注释 12345678910111213141516171819202122232425262728293031323334353637data () &#123; //设置纵坐标文字和显示类型 this.chartSettings = &#123; yAxisType: ['KMB'], yAxisName: ['人数/万'], &#125;, //选择全局文字，颜色，样式等配置 this.extend = &#123; barWidth: 25,//设置宽度为15px // x轴的文字倾斜 'xAxis.0.axisLabel.rotate': 45, 'xAxis.0.axisLabel.fontSize': 20,//x轴文本字体大小 'xAxis.0.axisLabel.fontWeight': 'bold',//x轴文本字体粗细 //设置随机颜色 series: &#123; label: &#123; show: true, position: \"top\" &#125;, color: function (value) &#123; return \"#\" + (\"00000\" + ((Math.random() * 16777215 + 0.5) &gt;&gt; 0).toString(16)).slice(-6); &#125; &#125; &#125;, //设置标题 this.chartTitle = &#123; // 文字啥的，用\\n可以换行 text: '2019各大编程语言人数排行', x: '25px', textStyle: &#123; fontSize: 20, fontWeight: 'normal', &#125; &#125; //设置数据 return &#123; chartData: &#123; columns: ['name', 'num'], rows: [] &#125; &#125;&#125;, 4_3、编写ajax请求，请求后端数据，绑定到柱状图 1234567891011121314151617181920//加载方法 created: function () &#123; var app = this; console.log(\"init\"); this.init() &#125;, methods: &#123; //查询数据 init: function () &#123; var app = this; axios .get(\"/userapi/findAll\") .then(function (response) &#123; app.chartData.rows = response.data; &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125;, &#125; 4_4、显示效果 在这里插入代码片 5、编写饼状图 5_1、编写饼状图 123&lt;template&gt; &lt;ve-pie :data=\"chartData\" :title=\"chartTitle\" :events=\"chartEvents\" :settings=\"chartSettings\"&gt;&lt;/ve-pie&gt;&lt;/template&gt; 5_2、在data中设置饼状图样式，和设置数据绑定集合 1234567891011121314151617181920212223242526272829303132data () &#123; //设置饼状图显示样式 this.chartSettings = &#123; radius: 150,//半径 offsetY: 250,//向下平移多少 //调节显示 label: &#123; normal: &#123; fontSize: 16,//字体大小 formatter: '&#123;b&#125;' + '\\n\\r' + '&#123;c&#125;' + '\\n\\r' + '(&#123;d&#125;%)'//显示那几种数据 &#125; &#125; &#125;, this.chartTitle = &#123; // 文字啥的，用\\n可以换行 text: '2019各大编程语言人数占比排行', x: '25px',//向右移动多少 textStyle: &#123; fontSize: 20, fontWeight: 'normal', &#125; &#125; return &#123; //饼状图数据绑定 chartData: &#123; columns: ['name', 'num'], rows: [] &#125; &#125; &#125;, 5_3、编写加载事件，和查询所有数据事件，通过ajax绑定饼状图数据 123456789101112131415161718192021//加载查询数据created: function () &#123; var app = this; console.log(\"init\"); this.init()&#125;,methods: &#123;//查询所有信息 init: function () &#123; var app = this; axios .get(\"/userapi/findAll\") .then(function (response) &#123; //向饼状图绑定数据 app.chartData.rows = response.data; &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125;,&#125; 5_4、显示效果 6、总结：绘制柱状图和饼状图，主要是对它自己封装的各种属性的配置和数据的绑定。总体来说操作性不难，但是太考验前端的各种属性配置，编写的时候一定要细心。后端比较简单，基本没有难点。 项目源码地址： 链接：https://pan.baidu.com/s/1Sud_cJKc7qo3TIrd7DB97w 提取码：873p","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://xuhao008.github.io/tags/elasticsearch/"}]},{"title":"springdatajpa+vue实现省市区三级联动","slug":"springDataJpa+vue实现三级联动","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2019/05/31/springDataJpa+vue实现三级联动/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/springDataJpa+vue%E5%AE%9E%E7%8E%B0%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8/","excerpt":"一，编写后端代码 1、创建springboot项目，添加 web、jpa、lombok、mysql、jdbc 启动器，并创建对应的层 2、编写省，市，区的实体（idea使用了lombok插件），SQL等项目文件文末自取 省份实体类：AddressProvince.java 12345678910111213141516@Data@Entity@Table(name = \"t_address_province\")public class AddressProvince &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) private Integer id; @Column(name = \"code\",nullable = false,length = 50) private String code; @Column(name = \"name\",nullable = false,length = 50) private String name;&#125; 城市实体类：AddressCity.java 12345678910111213141516171819@Data@Entity@Table(name = \"t_address_city\")public class AddressCity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) private Integer id; @Column(name = \"code\",nullable = false,length = 50) private String code; @Column(name = \"name\",nullable = false,length = 50) private String name; @Column(name = \"provincecode\",nullable = false,length = 50) private String provinceCode;&#125; 区域实体类：AddressTown.java 12345678910111213141516171819@Data@Entity@Table(name =\"t_address_town\")public class AddressTown &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) private Integer id; @Column(name = \"code\",nullable = false,length = 50) private String code; @Column(name = \"name\",nullable = false,length = 50) private String name; @Column(name = \"citycode\",nullable = false,length = 50) private String cityCode;&#125; 3、编写dao 12345/** * 省份dao */public interface ProvinceDao extends JpaRepository&lt;AddressProvince,Integer&gt; &#123;&#125;","text":"一，编写后端代码 1、创建springboot项目，添加 web、jpa、lombok、mysql、jdbc 启动器，并创建对应的层 2、编写省，市，区的实体（idea使用了lombok插件），SQL等项目文件文末自取 省份实体类：AddressProvince.java 12345678910111213141516@Data@Entity@Table(name = \"t_address_province\")public class AddressProvince &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) private Integer id; @Column(name = \"code\",nullable = false,length = 50) private String code; @Column(name = \"name\",nullable = false,length = 50) private String name;&#125; 城市实体类：AddressCity.java 12345678910111213141516171819@Data@Entity@Table(name = \"t_address_city\")public class AddressCity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) private Integer id; @Column(name = \"code\",nullable = false,length = 50) private String code; @Column(name = \"name\",nullable = false,length = 50) private String name; @Column(name = \"provincecode\",nullable = false,length = 50) private String provinceCode;&#125; 区域实体类：AddressTown.java 12345678910111213141516171819@Data@Entity@Table(name =\"t_address_town\")public class AddressTown &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\",unique = true,nullable = false,length = 50) private Integer id; @Column(name = \"code\",nullable = false,length = 50) private String code; @Column(name = \"name\",nullable = false,length = 50) private String name; @Column(name = \"citycode\",nullable = false,length = 50) private String cityCode;&#125; 3、编写dao 12345/** * 省份dao */public interface ProvinceDao extends JpaRepository&lt;AddressProvince,Integer&gt; &#123;&#125; 1234567891011/** * 城市dao */public interface CityDao extends JpaRepository&lt;AddressCity,Integer&gt; &#123; /** * 实现jpa的基本方法，根据省份编号查询城市信息 * @param provinceCode * @return */ public List&lt;AddressCity&gt; findAddressCityByProvinceCode(String provinceCode);&#125; 1234567891011/** * 区域dao */public interface TownDao extends JpaRepository&lt;AddressTown,Integer&gt; &#123; /** * 实现jpa基本方法，根据城市编号查询区域信息 * @param cityCode * @return */ public List&lt;AddressTown&gt; findAddressTownByCityCode(String cityCode);&#125; 4、编写service，调用dao接口方法，返回信息（省略…） 5、编写web，调用service方法，编写省，市，区各个接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 三级联动controller */@RestControllerpublic class AddressController &#123; @Autowired private ProvinceService provinceService; @Autowired private CityService cityService; @Autowired private TownService townService; /** * 查询所有省份信息 * @return */ @GetMapping(\"address\") public List&lt;AddressProvince&gt; findAll()&#123; return provinceService.findAll(); &#125; /** * 根据省份编号查询市级信息 * @param provinceCode * @return */ @GetMapping(\"addressCity/&#123;provinceCode&#125;\") public List&lt;AddressCity&gt; findByprovinceCode(@PathVariable(\"provinceCode\") String provinceCode)&#123; return cityService.findByprovinceCode(provinceCode); &#125; /** * 根据市级编号查询区域信息 * @param cityCode * @return */ @GetMapping(\"addressTown/&#123;cityCode&#125;\") public List&lt;AddressTown&gt; findBycityCode(@PathVariable(\"cityCode\") String cityCode)&#123; return townService.findBycityCode(cityCode); &#125;&#125; 6、使用工具Postman测试接口，返回json数据格式 6_1、部分返回的省份json数据 [ { “id”: 1, “code”: “110000”, “name”: “北京市” }, { “id”: 2, “code”: “120000”, “name”: “天津市” }, { “id”: 3, “code”: “130000”, “name”: “河北省” } ] 6_2、部分返回的城市json数据 [ { “id”: 5, “code”: “130100”, “name”: “石家庄市”, “provinceCode”: “130000” }, { “id”: 6, “code”: “130200”, “name”: “唐山市”, “provinceCode”: “130000” }, { “id”: 7, “code”: “130300”, “name”: “秦皇岛市”, “provinceCode”: “130000” } ] 6_3、返回的部分区域json数据 [ { “id”: 37, “code”: “130101”, “name”: “市辖区”, “cityCode”: “130100” }, { “id”: 38, “code”: “130102”, “name”: “长安区”, “cityCode”: “130100” }, { “id”: 39, “code”: “130103”, “name”: “桥东区”, “cityCode”: “130100” } ] 后端总结：后端比较简单，采用的是先查询所有省份信息，如何根据选中的省份，得到省份对应的编号，如何查询对应的城市和区域。当然后端也可以采用jpa的OneToMany的方式，一次性查询出所有的地址信息，返回数据，前端处理。考虑到每次触发方法都要查询所有信息，对数据库请求压力大，所以这样设计。 二，前端VUE+ELEMENT 1、创建vue项目 2、安装 axios 插件，在当前项目下的终端输入命令: ==npm install --save axios vue-axios== 安装 Element 插件，在当前项目下的终端输入命令:==npm i element-ui -S== 3、在 src 文件夹下的程序入口 main.js 中导入 12345678import axios from 'axios'import VueAxios from 'vue-axios'// element-ui 引入文件import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';//注册 VueAxios, axiosVue.use(VueAxios, axios)Vue.use(ElementUI) 4、创建vue文件，编写代码 4_1、使用element下拉组件，编写三级下拉框，具体参数示例可参考Element官网介绍 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;el-select v-model=\"provinceCode\" placeholder=\"省份\"&gt; &lt;el-option v-for=\"item in AddressProvince\" :key=\"item.code\" :label=\"item.name\" :value=\"item.code\" &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;el-select v-model=\"cityCode\" placeholder=\"城市\"&gt; &lt;el-option v-for=\"item in AddressCity\" :key=\"item.code\" :label=\"item.name\" :value=\"item.code\" &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;el-select v-model=\"value\" placeholder=\"区域\"&gt; &lt;el-option v-for=\"item in AddressTown\" :key=\"item.code\" :label=\"item.name\" :value=\"item.code\" &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt;&lt;/template&gt; 4_2、上方页面使用了vue.js的v-model和v-for绑定了下方data 12345678data () &#123; return &#123; AddressCity: [],//城市集合 AddressProvince: [],//省份集合 AddressTown: [],//区域集合 provinceCode: '',//获取选中时的省份编号 cityCode: '',//获取选中时的城市编号 value: ''&#125;//获取选中时区域的编号 4_3、在config文件夹下的index.js中配置跨域请求路径 12345678910proxyTable: &#123; // 表示以后以/pctapi 开头的请求，代理请求 http://localhost:8888 '/pctapi': &#123; target: 'http://localhost:8888', //后端接口地址 changeOrigin: true, //是否允许跨越 pathRewrite: &#123; '^/pctapi': '', //重写, &#125; &#125; &#125; 5、编写请求方法 5_1、在methods中编写加载init方法 1234567891011init () &#123; var app = this; axios.get(\"pctapi/address\").then(resp =&gt; &#123; // handle success app.AddressProvince = resp.data;//绑定到省份集合 &#125;) .catch(function (error) &#123; // handle error console.log(error); &#125;); &#125; 5_2、在methods在编写，查询城市findByprovinceCode 和查询区域findBycityCode 方法 1234567891011121314151617181920//查询城市信息 findByprovinceCode () &#123; var app = this; axios.get(\"/pctapi/addressCity/\" + app.provinceCode).then(resp =&gt; &#123; app.AddressCity = resp.data; &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125;, //查询区域信息 findBycityCode () &#123; var app = this; axios.get(\"/pctapi/addressTown/\" + app.cityCode).then(resp =&gt; &#123; app.AddressTown = resp.data; &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125; 6、在created中调用init方法，实现初始化请求，使页面加载时查询省份信息，并绑定到AddressProvince 省份集合中，使省份下拉框具有初始值 123created () &#123; this.init();&#125;, 7、在watch中编写监控省份和城市编号的方法，实现当选中省份使provinceCode值发生变化时，触发对应方法查询城市信息，区域同上 123456789101112131415161718watch: &#123;//监控一个值的变换 provinceCode: &#123; // handler () &#123; //在选中省份发生变化时，清空后方城市和区域集合的值，和绑定编号的值， //重新查询对应选中编号的城市和区域值 this.AddressCity = []; this.AddressTown = []; this.cityCode = \"\"; this.value = \"\"; this.findByprovinceCode(); &#125; &#125;, cityCode: &#123; handler () &#123; this.findBycityCode(); &#125; &#125;&#125; 8、运行截图 9、总结：前端vue项目，主要使用了element的页面，使用了axios的ajax发送请求，获取数据，v-for,v-model绑定数据。整体操作较简单。 后端项目源码和vue页面源码和SQL文件需要自取： 链接：https://pan.baidu.com/s/15yT8iuJK_STvxgQxs-Rsxg 提取码：ljal","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://xuhao008.github.io/tags/vue/"}]},{"title":"SpringBoot,JDBC连接数据库报错：java.lang.AbstractMethodError':oracle.jdbc.driver.T4CConnection.isValid(I)Z”","slug":"SpringBoot,JDBC连接oracle报错java.lang.AbstractMethodError_ oracle.jdbc.driver.T4CConnection.isValid(I)Z","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/05/31/SpringBoot,JDBC连接oracle报错java.lang.AbstractMethodError_ oracle.jdbc.driver.T4CConnection.isValid(I)Z/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/SpringBoot,JDBC%E8%BF%9E%E6%8E%A5oracle%E6%8A%A5%E9%94%99java.lang.AbstractMethodError_%20oracle.jdbc.driver.T4CConnection.isValid(I)Z/","excerpt":"问题：使用springboot，jdbc连接oracle10g数据库，启动项目报错 java.lang.AbstractMethodError:oracle.jdbc.driver.T4CConnection.isValid(I)Z 原因：oracle的jdbc连接包与jdk版本不匹配导致的，如果使用的是ojdbc14版本的，该版本不支持jdk1.8，建议更换ojdbc版本，如ojdbc8。 由于oracle部分版本，Maven坐标无法下载导入的，所以需要自己手动导入。 解决： 1、下载连接驱动包 1_1、建议去oracle官网下载驱动包：https://www.oracle.com/index.html 1_2、百度网盘下载： 链接：https://pan.baidu.com/s/1YrjbA9QizJMN0J_lsD0Vug 提取码：1ncu 2、将下载的jar包放到一个文件夹，执行cmd命令将jar包导入到你的maven仓库 执行的命令： mvn install:install-file -Dfile=E:/ojdbc8.jar -DgroupId=com.oracle -DartifactId=ojdbc8 -Dversion=12.2.0.1 -Dpackaging=jar 注意： 1、install-file -Dfile==》指的是你刚刚下载jar包保存的地址，也就是你执行cmd是文件夹 2、DgroupId DartifactId Dversion 其实就是 maven的这几个参数 3、导入坐标 &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;12.2.0.1&lt;/version&gt; &lt;/dependency&gt;","text":"问题：使用springboot，jdbc连接oracle10g数据库，启动项目报错 java.lang.AbstractMethodError:oracle.jdbc.driver.T4CConnection.isValid(I)Z 原因：oracle的jdbc连接包与jdk版本不匹配导致的，如果使用的是ojdbc14版本的，该版本不支持jdk1.8，建议更换ojdbc版本，如ojdbc8。 由于oracle部分版本，Maven坐标无法下载导入的，所以需要自己手动导入。 解决： 1、下载连接驱动包 1_1、建议去oracle官网下载驱动包：https://www.oracle.com/index.html 1_2、百度网盘下载： 链接：https://pan.baidu.com/s/1YrjbA9QizJMN0J_lsD0Vug 提取码：1ncu 2、将下载的jar包放到一个文件夹，执行cmd命令将jar包导入到你的maven仓库 执行的命令： mvn install:install-file -Dfile=E:/ojdbc8.jar -DgroupId=com.oracle -DartifactId=ojdbc8 -Dversion=12.2.0.1 -Dpackaging=jar 注意： 1、install-file -Dfile==》指的是你刚刚下载jar包保存的地址，也就是你执行cmd是文件夹 2、DgroupId DartifactId Dversion 其实就是 maven的这几个参数 3、导入坐标 &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;12.2.0.1&lt;/version&gt; &lt;/dependency&gt; 我这里是IDEA+jdk1.8+jdbc8,如果你的jdk是1.7或1.6就选择ojbc7,6等等","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://xuhao008.github.io/tags/oracle/"}]},{"title":"使用java爬虫爬取网站前台代码（html+css+js+img）","slug":"使用java爬虫爬取网站前台代码（html+css+js+img）","date":"2019-05-30T22:05:12.000Z","updated":"2020-08-05T03:27:43.110Z","comments":true,"path":"2019/05/31/使用java爬虫爬取网站前台代码（html+css+js+img）/","link":"","permalink":"http://xuhao008.github.io/2019/05/31/%E4%BD%BF%E7%94%A8java%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%89%8D%E5%8F%B0%E4%BB%A3%E7%A0%81%EF%BC%88html+css+js+img%EF%BC%89/","excerpt":"使用java爬虫爬取网站前台代码（html+css+js+img） 一、爬虫 1、什么是爬虫 爬虫主要针对与网络网页，又称网络爬虫、网络蜘蛛，可以自动化浏览网络中的信息，或者说是一种网络机器人。它们被广泛用于互联网搜索引擎或其他类似网站，以获取或更新这些网站的内容和检索方式。它们可以自动采集所有其能够访问到的页面内容，以便程序做下一步的处理。 2、为什么我们要爬取数据 在大数据时代,我们要获取更多数据,就要进行数据的挖掘、分析、筛选,比如当我们做一个项目的时候,需要大量真实的数据的时候,就需要去某些网站进行爬取,有些网站的数据爬取后保存到数据库还不能够直接使用,需要进行清洗、过滤后才能使用,我们知道有些数据是非常珍贵的。 二、Jsoup 1、什么是Jsoup jsoup 是一款 Java 的HTML 解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于JQuery的操作方法来取出和操作数据。该版本包含一个支持 HTML5 的解析器分支，可确保跟现在的浏览器一样解析 HTML 的方法，同时降低了解析的时间和内存的占用。 2、Jsoup主要功能 2_1、从一个URL，文件或字符串中解析HTML； 2_2、使用DOM或CSS选择器来查找、取出数据； 2_3、可操作HTML元素、属性、文本 详细介绍参考：https://www.cnblogs.com/zhangyinhua/p/8037599.html 三、创建项目 1、pom文件 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.googlecode.juniversalchardet&lt;/groupId&gt; &lt;artifactId&gt;juniversalchardet&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie.modules&lt;/groupId&gt; &lt;artifactId&gt;org-apache-commons-httpclient&lt;/artifactId&gt; &lt;version&gt;6.2.0.CR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、以正版中国网站为例，首先我们先获取页面 1234567891011121314151617181920212223242526272829303132333435363738394041public class RequestAndResponseTool &#123; public static Page sendRequstAndGetResponse(String url) &#123; Page page = null; // 1.生成 HttpClinet 对象并设置参数 HttpClient httpClient = new HttpClient(); // 设置 HTTP 连接超时 5s httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(5000); // 2.生成 GetMethod 对象并设置参数 GetMethod getMethod = new GetMethod(url); // 设置 get 请求超时 5s getMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT, 5000); // 设置请求重试处理 getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler()); // 3.执行 HTTP GET 请求 try &#123; int statusCode = httpClient.executeMethod(getMethod); // 判断访问的状态码 if (statusCode != HttpStatus.SC_OK) &#123; System.err.println(\"Method failed: \" + getMethod.getStatusLine()); &#125; // 4.处理 HTTP 响应内容 byte[] responseBody = getMethod.getResponseBody();// 读取为字节 数组 String contentType = getMethod.getResponseHeader(\"Content-Type\").getValue(); // 得到当前返回类型 page = new Page(responseBody,url,contentType); //封装成为页面 &#125; catch (HttpException e) &#123; // 发生致命的异常，可能是协议不对或者返回的内容有问题 System.out.println(\"Please check your provided http address!\"); e.printStackTrace(); &#125; catch (IOException e) &#123; // 发生网络异常 e.printStackTrace(); &#125; finally &#123; // 释放连接 getMethod.releaseConnection(); &#125; return page; &#125;&#125; 3、获取响应内容，放入page","text":"使用java爬虫爬取网站前台代码（html+css+js+img） 一、爬虫 1、什么是爬虫 爬虫主要针对与网络网页，又称网络爬虫、网络蜘蛛，可以自动化浏览网络中的信息，或者说是一种网络机器人。它们被广泛用于互联网搜索引擎或其他类似网站，以获取或更新这些网站的内容和检索方式。它们可以自动采集所有其能够访问到的页面内容，以便程序做下一步的处理。 2、为什么我们要爬取数据 在大数据时代,我们要获取更多数据,就要进行数据的挖掘、分析、筛选,比如当我们做一个项目的时候,需要大量真实的数据的时候,就需要去某些网站进行爬取,有些网站的数据爬取后保存到数据库还不能够直接使用,需要进行清洗、过滤后才能使用,我们知道有些数据是非常珍贵的。 二、Jsoup 1、什么是Jsoup jsoup 是一款 Java 的HTML 解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于JQuery的操作方法来取出和操作数据。该版本包含一个支持 HTML5 的解析器分支，可确保跟现在的浏览器一样解析 HTML 的方法，同时降低了解析的时间和内存的占用。 2、Jsoup主要功能 2_1、从一个URL，文件或字符串中解析HTML； 2_2、使用DOM或CSS选择器来查找、取出数据； 2_3、可操作HTML元素、属性、文本 详细介绍参考：https://www.cnblogs.com/zhangyinhua/p/8037599.html 三、创建项目 1、pom文件 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.googlecode.juniversalchardet&lt;/groupId&gt; &lt;artifactId&gt;juniversalchardet&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie.modules&lt;/groupId&gt; &lt;artifactId&gt;org-apache-commons-httpclient&lt;/artifactId&gt; &lt;version&gt;6.2.0.CR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、以正版中国网站为例，首先我们先获取页面 1234567891011121314151617181920212223242526272829303132333435363738394041public class RequestAndResponseTool &#123; public static Page sendRequstAndGetResponse(String url) &#123; Page page = null; // 1.生成 HttpClinet 对象并设置参数 HttpClient httpClient = new HttpClient(); // 设置 HTTP 连接超时 5s httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(5000); // 2.生成 GetMethod 对象并设置参数 GetMethod getMethod = new GetMethod(url); // 设置 get 请求超时 5s getMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT, 5000); // 设置请求重试处理 getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler()); // 3.执行 HTTP GET 请求 try &#123; int statusCode = httpClient.executeMethod(getMethod); // 判断访问的状态码 if (statusCode != HttpStatus.SC_OK) &#123; System.err.println(\"Method failed: \" + getMethod.getStatusLine()); &#125; // 4.处理 HTTP 响应内容 byte[] responseBody = getMethod.getResponseBody();// 读取为字节 数组 String contentType = getMethod.getResponseHeader(\"Content-Type\").getValue(); // 得到当前返回类型 page = new Page(responseBody,url,contentType); //封装成为页面 &#125; catch (HttpException e) &#123; // 发生致命的异常，可能是协议不对或者返回的内容有问题 System.out.println(\"Please check your provided http address!\"); e.printStackTrace(); &#125; catch (IOException e) &#123; // 发生网络异常 e.printStackTrace(); &#125; finally &#123; // 释放连接 getMethod.releaseConnection(); &#125; return page; &#125;&#125; 3、获取响应内容，放入page 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Page &#123; private byte[] content ; private String html ; //网页源码字符串 private Document doc ;//网页Dom文档 private String charset ;//字符编码 private String url ;//url路径 private String contentType ;// 内容类型 public Page(byte[] content , String url , String contentType)&#123; this.content = content ; this.url = url ; this.contentType = contentType ; &#125; public String getCharset() &#123; return charset; &#125; public String getUrl()&#123;return url ;&#125; public String getContentType()&#123; return contentType ;&#125; public byte[] getContent()&#123; return content ;&#125; public void setContent(byte[] content) &#123; this.content = content; &#125; /** * 返回网页的源码字符串 * * @return 网页的源码字符串 */ public String getHtml() &#123; if (html != null) &#123; return html; &#125; if (content == null) &#123; return null; &#125; if(charset==null)&#123; charset = CharsetDetector.guessEncoding(content); // 根据内容来猜测 字符编码 &#125; try &#123; this.html = new String(content, charset); return html; &#125; catch (UnsupportedEncodingException ex) &#123; ex.printStackTrace(); return null; &#125; &#125; /* * 得到文档 * */ public Document getDoc()&#123; if (doc != null) &#123; return doc; &#125; try &#123; this.doc = Jsoup.parse(getHtml(), url); return doc; &#125; catch (Exception ex) &#123; ex.printStackTrace(); return null; &#125; &#125;&#125; 4、储存爬取的网页文本数据，FileTool 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class FileTool &#123; private static String dirPath; /** * getMethod.getResponseHeader(\"Content-Type\").getValue() * 根据 URL 和网页类型生成需要保存的网页的文件名，去除 URL 中的非文件名字符 */ private static String getFileNameByUrl(String url, String contentType) &#123; //去除 http:// //text/html 类型 if (contentType.indexOf(\"html\") != -1) &#123; url = url.replaceAll(\"[\\\\?/:*|&lt;&gt;\\\"]\", \"_\") + \".html\"; return url; &#125;else&#123; int i = url.lastIndexOf(\"/\"); url = url.substring(i+1,url.length()); return url; &#125; &#125; /* * 生成目录 * */ private static void mkdir() &#123; if (dirPath == null) &#123; dirPath = Class.class.getClass().getResource(\"/\").getPath() + \"temp\\\\\"; &#125; File fileDir = new File(dirPath); if (!fileDir.exists()) &#123; fileDir.mkdir(); &#125; &#125; /** * 保存网页字节数组到本地文件，filePath 为要保存的文件的相对地址 */ public static void saveToLocal(Page page) &#123; mkdir(); String fileName = getFileNameByUrl(page.getUrl(), page.getContentType()) ; String filePath = dirPath + fileName ; byte[] data = page.getContent(); try &#123; DataOutputStream out = new DataOutputStream(new FileOutputStream(new File(filePath))); for (int i = 0; i &lt; data.length; i++) &#123; out.write(data[i]); &#125; out.flush(); out.close(); System.out.println(\"文件：\"+ fileName + \"已经被存储在\"+ filePath ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5、主方法，配置网站路径和css，js，img的路径过滤，配置爬取文件存储地址，并获取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174public class MyCrawler &#123; /** * 使用种子初始化 URL 队列 * * @param seeds 种子 URL * @return */ private void initCrawlerWithSeeds(String[] seeds) &#123; for (int i = 0; i &lt; seeds.length; i++)&#123; Links.addUnvisitedUrlQueue(seeds[i]); &#125; &#125; /** * 抓取过程 * * @param seeds * @return */ public void crawling2(String[] seeds) &#123; //初始化 URL 队列 initCrawlerWithSeeds(seeds); //定义过滤器，提取以 http://www.baidu.com 开头的链接 LinkFilter filter = new LinkFilter() &#123; public boolean accept(String url) &#123; if (url.startsWith(\"https://getitfree.cn/\")) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;; URL url; int responsecode; HttpURLConnection urlConnection; BufferedReader reader; String line; String filePath=\"F:\\\\IDEAProject\\\\crawl\\\\crawl\\\\target\\\\classes\\\\temp\\\\index.html\"; //循环条件：待抓取的链接不空且抓取的网页不多于 1000 while (!Links.unVisitedUrlQueueIsEmpty() &amp;&amp; Links.getVisitedUrlNum() &lt;= 1000) &#123; //先从待访问的序列中取出第一个； String visitUrl = (String) Links.removeHeadOfUnVisitedUrlQueue(); if (visitUrl == null)&#123; continue; &#125; //根据URL得到page; Page page = RequestAndResponseTool.sendRequstAndGetResponse(visitUrl); Elements es = PageParserTool.select(page,\"img\"); Iterator iterator = es.iterator(); while(iterator.hasNext()) &#123; Element element = (Element) iterator.next(); if (element.hasAttr(\"href\")) &#123; &#125; else if (element.hasAttr(\"src\")) &#123; String src = element.attr(\"src\"); if (src.indexOf(\"?\")!=-1)&#123; continue; &#125; src = src.substring(src.lastIndexOf(\"/\") + 1); element.attr(\"src\", src); &#125; &#125; es =PageParserTool.select(page,\"link\"); iterator = es.iterator(); while(iterator.hasNext()) &#123; Element element = (Element) iterator.next(); if (element.hasAttr(\"href\")) &#123; String href = element.attr(\"href\"); if (href.indexOf(\"?\")!=-1)&#123; continue; &#125; href = href.substring(href.lastIndexOf(\"/\") + 1); element.attr(\"href\", href); &#125; else if (element.hasAttr(\"src\")) &#123; String src = element.attr(\"src\"); src = src.substring(src.lastIndexOf(\"/\") + 1); element.attr(\"src\", src); &#125; &#125; es =PageParserTool.select(page,\"script\"); iterator = es.iterator(); while(iterator.hasNext()) &#123; Element element = (Element) iterator.next(); if (element.hasAttr(\"href\")) &#123; String href = element.attr(\"href\"); //System.out.println(\"src:\" + src); href = href.substring(href.lastIndexOf(\"/\") + 1); element.attr(\"href\", href); &#125; else if (element.hasAttr(\"src\")) &#123; String src = element.attr(\"src\"); //System.out.println(\"src:\" + src); if (src.indexOf(\"?\")!=-1)&#123; continue; &#125; src = src.substring(src.lastIndexOf(\"/\") + 1); element.attr(\"src\", src); &#125; &#125; try &#123; File file = new File(filePath); PrintStream ps = new PrintStream(new FileOutputStream(file)); ps.append(page.getDoc().toString()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void crawling(String[] seeds) &#123; //初始化 URL 队列 initCrawlerWithSeeds(seeds); //定义过滤器，提取以 http://www.baidu.com 开头的链接 LinkFilter filter = new LinkFilter() &#123; public boolean accept(String url) &#123; if (url.startsWith(\"https://getitfree.cn/\")) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;; //循环条件：待抓取的链接不空且抓取的网页不多于 1000 while (!Links.unVisitedUrlQueueIsEmpty() &amp;&amp; Links.getVisitedUrlNum() &lt;= 1000) &#123; //先从待访问的序列中取出第一个； String visitUrl = (String) Links.removeHeadOfUnVisitedUrlQueue(); if (visitUrl == null)&#123; continue; &#125; //根据URL得到page; Page page = RequestAndResponseTool.sendRequstAndGetResponse(visitUrl); //将保存文件 FileTool.saveToLocal(page); //将已经访问过的链接放入已访问的链接中； Links.addVisitedUrlSet(visitUrl); //得到超链接 Set&lt;String&gt; links = PageParserTool.getLinks(page,\"img\"); for (String link : links) &#123; Links.addUnvisitedUrlQueue(link); System.out.println(\"新增爬取路径: \" + link); &#125; links = PageParserTool.getLinks(page,\"script\"); for (String link : links) &#123; Links.addUnvisitedUrlQueue(link); System.out.println(\"新增爬取路径: \" + link); &#125; links = PageParserTool.getLinks(page,\"link\"); for (String link : links) &#123; Links.addUnvisitedUrlQueue(link); System.out.println(\"新增爬取路径: \" + link); &#125; &#125; &#125; //main 方法入口 public static void main(String[] args) &#123; MyCrawler crawler = new MyCrawler(); crawler.crawling2(new String[]&#123;\"https://getitfree.cn/\"&#125;); crawler.crawling(new String[]&#123;\"https://getitfree.cn/\"&#125;); &#125;&#125; 四、爬取结果和dome源码等 1、结果 2、该博客只有部分代码，如果需要dome源码，自取 链接：https://pan.baidu.com/s/1THFARMlsbY_s51-LYWZZGw 提取码：nezg 3、路还很长，乘风破浪，各位加油！！！！","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://xuhao008.github.io/tags/docker/"}]},{"title":"JSP中使用JSTL","slug":"JSP中JSTL学习","date":"2019-05-10T22:05:12.000Z","updated":"2020-08-05T03:27:43.095Z","comments":true,"path":"2019/05/11/JSP中JSTL学习/","link":"","permalink":"http://xuhao008.github.io/2019/05/11/JSP%E4%B8%ADJSTL%E5%AD%A6%E4%B9%A0/","excerpt":"JSP中JSTL学习 &lt;%@ page language=“java” import=“java.util.*” pageEncoding=“utf-8”%&gt; &lt;%@taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt; &lt;%– JSTL学习： 作用： 提高jsp中的逻辑代码编写效率，使用标签 使用： JSTL的核心标签库 JSTL的格式化标签库 JSTL的sql标签库 JSTL的xml标签库 JSTL的核心标签库： 1、导入jar包 2、声明jstl标签库的引入（核心标签库） &lt;%@taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt; 3、内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344基本标签： &lt;c:out value=\"数据\" default=\"默认值\"&gt;&lt;/c:out&gt; 数据可以作为常量也可以是EL表达式。 作用：将数据输出给客户端 &lt;c:set var=\"hello\" value=\"hello page\" scope=\"page\"&gt;&lt;/c:set&gt; 作用：存储数据到作用域中 var：表示存储的键名 value：表示存储的数据 scope：表示要存储的作用域对象page request session application &lt;c:remove var=\"hello\" scope=\"page\"/&gt;&lt;br/&gt; 作用：删除作用域中的指定键数据 var：表示存储的键名 scope：表示要删除的作用域 注意： 如果不指定作用域，则删除所有逻辑标签： &lt;c:if test=\"$&#123;表达式&#125;\"&gt;前端代码&lt;/c:if&gt; 作用：进行逻辑判断，相当于java代码的单分支判断 注意： 逻辑判断标签需要依赖于El的逻辑运算，也就是表达式中涉及到的数据必须从作用域中获取 &lt;c:choose&gt; &lt;c:when test=\"条件\"&gt;判断成功执行内容&lt;/c:when&gt; &lt;c:when test=\"\"&gt;&lt;/c:when&gt; ......... &lt;c:otherwise&gt;判断都不成立执行&lt;/c:otherwise&gt; &lt;/c:choose&gt; 作用：用来进行多条件的逻辑判断，类似java的多分枝语句 注意： 条件成立只会执行一次，都不成立执行otherwise- 循环标签： &lt;c:forEach begin=\"1\" end=\"4\" step=\"2\"&gt;循环体&lt;br/&gt;&lt;/c:forEach&gt; 作用： 循环内容进行处理 使用： begin：声明循环开始位置 end：声明循环结束位置 step：每次循环长度 VarStatus：声明变量记录每次循环的数据（角标，次数，是否是第一次循环，是否是最后一次循环） $&#123;vs.index&#125;---$&#123;vs.count&#125;--$&#123;vs.first&#125;---$&#123;vs.last&#125;&lt;br/&gt;&lt;/c:forEach&gt; 注意：数据存储在作用域中，需要使用El表达式获取 items:声明要遍历的对象，结合EL表达式获取对象 var:声明变量记录每次循环的结果，结果存储在El表达式中，需要使用El表达式获取。 基本标签学习 1234567891011121314 &lt;% request.setAttribute(\"str\", \"学习使我快乐\"); %&gt;&lt;c:out value=\"哈哈\"&gt;&lt;/c:out&gt;----$&#123;str&#125;&lt;br/&gt;&lt;c:out value=\"$&#123;str2&#125;\" default=\"哈哈11\"&gt;&lt;/c:out&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello page\" scope=\"page\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello request\" scope=\"request\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello request\" scope=\"session\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello application\" scope=\"application\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:out value=\"$&#123;hello&#125;\"&gt;&lt;/c:out&gt;&lt;c:out value=\"$&#123;sessionScope.hello&#125;\"&gt;&lt;/c:out&gt;&lt;br/&gt;&lt;c:remove var=\"hello\" scope=\"page\"/&gt;&lt;br/&gt;&lt;c:out value=\"$&#123;hello&#125;\"&gt;&lt;/c:out&gt; &lt;br/&gt; 逻辑标签学习 1234567891011121314151617181920 &lt;c:set var=\"a\" value=\"5\"&gt;&lt;/c:set&gt;&lt;c:if test=\"$&#123;a&gt;3&#125;\"&gt; &lt;b&gt;学习&lt;/b&gt;&lt;/c:if&gt;&lt;c:set var=\"xx\" value=\"85\"&gt;&lt;/c:set&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;xx&gt;=90&#125;\"&gt; &lt;i&gt;快乐&lt;/i&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;xx&lt;90&amp;&amp;xx&gt;=80&#125;\"&gt; &lt;i&gt;了啦啦啦&lt;/i&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;xx&lt;80&#125;\"&gt; &lt;i&gt;男男女女女&lt;/i&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;i&gt;中&lt;/i&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签学习 常量循环 1&lt;c:forEach begin=\"1\" end=\"4\" step=\"1\" varStatus=\"vs\"&gt;1111---$&#123;vs.index&#125;---$&#123;vs.count&#125;--$&#123;vs.first&#125;---$&#123;vs.last&#125;&lt;br/&gt;&lt;/c:forEach&gt;","text":"JSP中JSTL学习 &lt;%@ page language=“java” import=“java.util.*” pageEncoding=“utf-8”%&gt; &lt;%@taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt; &lt;%– JSTL学习： 作用： 提高jsp中的逻辑代码编写效率，使用标签 使用： JSTL的核心标签库 JSTL的格式化标签库 JSTL的sql标签库 JSTL的xml标签库 JSTL的核心标签库： 1、导入jar包 2、声明jstl标签库的引入（核心标签库） &lt;%@taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt; 3、内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344基本标签： &lt;c:out value=\"数据\" default=\"默认值\"&gt;&lt;/c:out&gt; 数据可以作为常量也可以是EL表达式。 作用：将数据输出给客户端 &lt;c:set var=\"hello\" value=\"hello page\" scope=\"page\"&gt;&lt;/c:set&gt; 作用：存储数据到作用域中 var：表示存储的键名 value：表示存储的数据 scope：表示要存储的作用域对象page request session application &lt;c:remove var=\"hello\" scope=\"page\"/&gt;&lt;br/&gt; 作用：删除作用域中的指定键数据 var：表示存储的键名 scope：表示要删除的作用域 注意： 如果不指定作用域，则删除所有逻辑标签： &lt;c:if test=\"$&#123;表达式&#125;\"&gt;前端代码&lt;/c:if&gt; 作用：进行逻辑判断，相当于java代码的单分支判断 注意： 逻辑判断标签需要依赖于El的逻辑运算，也就是表达式中涉及到的数据必须从作用域中获取 &lt;c:choose&gt; &lt;c:when test=\"条件\"&gt;判断成功执行内容&lt;/c:when&gt; &lt;c:when test=\"\"&gt;&lt;/c:when&gt; ......... &lt;c:otherwise&gt;判断都不成立执行&lt;/c:otherwise&gt; &lt;/c:choose&gt; 作用：用来进行多条件的逻辑判断，类似java的多分枝语句 注意： 条件成立只会执行一次，都不成立执行otherwise- 循环标签： &lt;c:forEach begin=\"1\" end=\"4\" step=\"2\"&gt;循环体&lt;br/&gt;&lt;/c:forEach&gt; 作用： 循环内容进行处理 使用： begin：声明循环开始位置 end：声明循环结束位置 step：每次循环长度 VarStatus：声明变量记录每次循环的数据（角标，次数，是否是第一次循环，是否是最后一次循环） $&#123;vs.index&#125;---$&#123;vs.count&#125;--$&#123;vs.first&#125;---$&#123;vs.last&#125;&lt;br/&gt;&lt;/c:forEach&gt; 注意：数据存储在作用域中，需要使用El表达式获取 items:声明要遍历的对象，结合EL表达式获取对象 var:声明变量记录每次循环的结果，结果存储在El表达式中，需要使用El表达式获取。 基本标签学习 1234567891011121314 &lt;% request.setAttribute(\"str\", \"学习使我快乐\"); %&gt;&lt;c:out value=\"哈哈\"&gt;&lt;/c:out&gt;----$&#123;str&#125;&lt;br/&gt;&lt;c:out value=\"$&#123;str2&#125;\" default=\"哈哈11\"&gt;&lt;/c:out&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello page\" scope=\"page\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello request\" scope=\"request\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello request\" scope=\"session\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:set var=\"hello\" value=\"hello application\" scope=\"application\"&gt;&lt;/c:set&gt;&lt;br/&gt;&lt;c:out value=\"$&#123;hello&#125;\"&gt;&lt;/c:out&gt;&lt;c:out value=\"$&#123;sessionScope.hello&#125;\"&gt;&lt;/c:out&gt;&lt;br/&gt;&lt;c:remove var=\"hello\" scope=\"page\"/&gt;&lt;br/&gt;&lt;c:out value=\"$&#123;hello&#125;\"&gt;&lt;/c:out&gt; &lt;br/&gt; 逻辑标签学习 1234567891011121314151617181920 &lt;c:set var=\"a\" value=\"5\"&gt;&lt;/c:set&gt;&lt;c:if test=\"$&#123;a&gt;3&#125;\"&gt; &lt;b&gt;学习&lt;/b&gt;&lt;/c:if&gt;&lt;c:set var=\"xx\" value=\"85\"&gt;&lt;/c:set&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;xx&gt;=90&#125;\"&gt; &lt;i&gt;快乐&lt;/i&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;xx&lt;90&amp;&amp;xx&gt;=80&#125;\"&gt; &lt;i&gt;了啦啦啦&lt;/i&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;xx&lt;80&#125;\"&gt; &lt;i&gt;男男女女女&lt;/i&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;i&gt;中&lt;/i&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签学习 常量循环 1&lt;c:forEach begin=\"1\" end=\"4\" step=\"1\" varStatus=\"vs\"&gt;1111---$&#123;vs.index&#125;---$&#123;vs.count&#125;--$&#123;vs.first&#125;---$&#123;vs.last&#125;&lt;br/&gt;&lt;/c:forEach&gt; 动态循环List 123456789101112131415161718JSP中存入request域值&lt;%ArrayList&lt;String&gt; str=new ArrayList&lt;&gt;(); str.add(\"a\"); str.add(\"b\"); str.add(\"c\"); request.setAttribute(\"list\", str);%&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"str\" &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;$&#123;str&#125;&lt;/td&gt; &lt;td&gt;$&#123;str&#125;&lt;/td&gt; &lt;td&gt;$&#123;str&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/c:forEach&gt; 动态循环Map 12345678910111213141516&lt;%HashMap&lt;String ,String&gt; map=new HashMap&lt;String,String&gt;(); map.put(\"1\", \"a\"); map.put(\"2\", \"b\"); map.put(\"3\", \"c\"); request.setAttribute(\"map\", map);%&gt;&lt;c:forEach items=\"$&#123;map&#125;\" var=\"map\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;$&#123;map.key&#125;---$&#123;map.value&#125;&lt;/td&gt; &lt;td&gt;$&#123;map.key&#125;---$&#123;map.value&#125;&lt;/td&gt; &lt;td&gt;$&#123;map.key&#125;---$&#123;map.value&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/c:forEach&gt;","categories":[],"tags":[{"name":"JSTL","slug":"JSTL","permalink":"http://xuhao008.github.io/tags/JSTL/"}]},{"title":"快速搭建SpringCloud环境","slug":"快速搭建SpringCloud环境","date":"2019-04-05T22:05:12.000Z","updated":"2020-08-05T03:27:43.142Z","comments":true,"path":"2019/04/06/快速搭建SpringCloud环境/","link":"","permalink":"http://xuhao008.github.io/2019/04/06/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BASpringCloud%E7%8E%AF%E5%A2%83/","excerpt":"前言：在我上篇博客中，详细介绍了，Spring Cloud的一些概念和组件，如果你是新手，建议你可以先去看看： https://blog.csdn.net/weixin_44209403/article/details/103493907 一、项目搭建 下面我们来一步步搭建spring Cloud生产环境（如果你是老手可以跳过这里） 下面我是通过截图一步步来演示的。 同时到父项目的pom.xml中导入我们的依赖，进行子项目的依赖版本控制 pom.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xkkj&lt;/groupId&gt; &lt;artifactId&gt;springcloudparent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springcloudparent&lt;/name&gt; &lt;description&gt;springCloud父级项目&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--springCloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 到这里我们的父项目就建好了，因为我们使用的是Spring Cloud微服务，所以框架结构为一个基座+多个子模块，该项目就是用来管理子项目依赖，和提供一个统一的工作区间。 1、创建Eureka注册中心 如果你看过我的上篇帖子或者了解过Spring Cloud相关组件，你应该知道，Eureka是服务的管理者（服务注册和发现）。,而我们的微服务就是把一整个后台应用拆分成小的功能模块, 那么这些模块之间就是通过将服务注册到Eureka，通过注册中心来相互通信的? 那么我们现在就来创建Eureka注册中心项目 pom.xml文件 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloudparent&lt;/artifactId&gt; &lt;groupId&gt;com.xkkj&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;SpringCloud-EureKa&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka服务端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类： 1234567@SpringBootApplication@EnableEurekaServerpublic class EureKaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EureKaApplication.class,args); &#125;&#125;","text":"前言：在我上篇博客中，详细介绍了，Spring Cloud的一些概念和组件，如果你是新手，建议你可以先去看看： https://blog.csdn.net/weixin_44209403/article/details/103493907 一、项目搭建 下面我们来一步步搭建spring Cloud生产环境（如果你是老手可以跳过这里） 下面我是通过截图一步步来演示的。 同时到父项目的pom.xml中导入我们的依赖，进行子项目的依赖版本控制 pom.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xkkj&lt;/groupId&gt; &lt;artifactId&gt;springcloudparent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springcloudparent&lt;/name&gt; &lt;description&gt;springCloud父级项目&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--springCloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 到这里我们的父项目就建好了，因为我们使用的是Spring Cloud微服务，所以框架结构为一个基座+多个子模块，该项目就是用来管理子项目依赖，和提供一个统一的工作区间。 1、创建Eureka注册中心 如果你看过我的上篇帖子或者了解过Spring Cloud相关组件，你应该知道，Eureka是服务的管理者（服务注册和发现）。,而我们的微服务就是把一整个后台应用拆分成小的功能模块, 那么这些模块之间就是通过将服务注册到Eureka，通过注册中心来相互通信的? 那么我们现在就来创建Eureka注册中心项目 pom.xml文件 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloudparent&lt;/artifactId&gt; &lt;groupId&gt;com.xkkj&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;SpringCloud-EureKa&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka服务端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类： 1234567@SpringBootApplication@EnableEurekaServerpublic class EureKaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EureKaApplication.class,args); &#125;&#125; 配置application.yml, 其实application.properties和application.yml这两个配置文件都可以配置工程, 只不过相比之下yml更直观一些,不过请注意缩进, 因为yml使用缩进来区分不同字段的 yml配置文件： 123456789101112server: # 配置服务端口 port: 8081eureka: client: service-url: # 配置eureka服务器地址 defaultZone: http://127.0.0.1:8081/eureka #是否需要将自己注册到注册中心(注册中心集群需要设置为true) register-with-eureka: false #是否需要搜索服务信息 因为自己是注册中心所以为false fetch-registry: false 注意：这里如果yml文件运行时候报错，请先将中文注释删除，或者修改编码格式。 下面我们去自己的启动类，启动项目，启动后，我们可以看到日志输出 那么我们现在通过浏览器访问注册中心客户端：http://localhost:8081 我们可以正确访问，就说明我们的注册中心配置好了，是不是很简单呢。 二、创建微服务 刚刚我们创建了注册中心，现在我们就来创建两个服务，待会我们来实现他们自己的调用关系。 下面我们分别导入maven坐标和创建启动类和配置文件 pom.xml,两个项目都导入下方这个坐标 123456789101112&lt;dependencies&gt; &lt;!--eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 分别创建启动类 启动类A 1234567@SpringBootApplication@EnableEurekaClientpublic class ServiceAApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceAApplication.class,args); &#125;&#125; 启动类B 1234567@SpringBootApplication@EnableEurekaClientpublic class ServiceBApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceBApplication.class,args); &#125;&#125; yml配置A 123456789101112131415161718192021server: # 服务端口号 port: 8888spring: application: # 服务名称 - 服务之间使用名称进行通讯 name: service-aeureka: client: service-url: # 填写注册中心服务器地址 defaultZone: http://localhost:8081/eureka # 是否需要将自己注册到注册中心 register-with-eureka: true # 是否需要搜索服务信息 fetch-registry: true instance: # 使用ip地址注册到注册中心 prefer-ip-address: true # 注册中心列表中显示的状态参数 instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; yml配置B 123456789101112131415161718192021server: # 服务端口号 port: 9999spring: application: # 服务名称-服务之间使用名称进行通讯 name: service-beureka: client: service-url: # 填写注册中心服务器地址 defaultZone: http://localhost:8081/eureka # 是否需要将自己注册到注册中心 register-with-eureka: true # 是否需要搜索服务信息 fetch-registry: true instance: # 使用ip地址注册到注册中心 prefer-ip-address: true # 注册中心列表中显示的状态参数 instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; 接下来，我们运行两个服务看看效果 启动后，我们可以去注册中心看看，你会发现我们的服务已经注册到了注册中心 那么接下来我们就通过部分代码来让大家看看效果 首先我们到Service-A中编写一个接口，创建controller HelloWorldController.java 123456789@RestController@RequestMapping(\"hello\")public class HelloWorldController &#123; @GetMapping public String hello()&#123; return \"欢迎来到Spring Cloud微服务的世界！\"; &#125;&#125; 接下来我们重启Service-A项目 访问：http://localhost:8888/hello 访问成功，但是现在这种访问方式只是我们平时单模块开发时，项目的服务方式，这里都没有使用到注册中心，所以我们现在使用Service-B访问Service-A的接口，该如何实现呢。下面我们一起来看看 要想Service-B调用Service-A，就需要用到eurka(注册中心)和feign客户端了，所以我们现在需要先导入feign的maven坐标。 B中导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 编写client接口，用于访问Service-A服务 HelloworldClient.java 123456@FeignClient(\"Service-A\")public interface HelloworldClient &#123; @GetMapping(\"hello\") public String hello();&#125; 编写controller，注入上方的HelloworldClient 1234567891011121314151617181920212223package com.xkkj.serviceb.controller;import com.xkkj.serviceb.client.HelloworldClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @description: HelloWorldController * @author: xuhao * @time: 2019/12/12 17:10 */@RestControllerpublic class HelloWorldController &#123; @Autowired private HelloworldClient helloworldClient; @GetMapping(\"hello\") public String hello()&#123; return helloworldClient.hello(); &#125;&#125; 最后我们在启动类上加上注解：@EnableFeignClients，就可以实现服务间的调用 12345678@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class ServiceBApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceBApplication.class,args); &#125;&#125; 最后我们运行看看效果：http://localhost:9999/hello 显然调用成功了，但是还有一个情况我们没有考虑，服务间的请求是有默认时间限制的，如果超过时间就会报错，feign默认的响应时间是1000mm，所以我们在配置文件中配置feign的超时时间即可 在service-b的yml中配置： 12345ribbon: #建立连接超时时间 ReadTimeout: 5000 #读取资源超时间 ConnectTimeout: 5000 这样就可以有效避免因为响应慢而导致报错的这种情况。 这里的ribbon相信大家如果有一定了解，应该都知道它可以实现负载均衡 那么我们现在来看看，它是实现的效果。 首先我们将Service-A的controller方法，输出一条相信到控制台，我们就可以清晰看到那个服务执行了。 123456789101112131415/** * @description: HelloWorldController * @author: xuhao * @time: 2019/12/12 16:43 */@RestController@RequestMapping(\"hello\")public class HelloWorldController &#123; @GetMapping public String hello()&#123; System.out.println(\"欢迎来到Spring Cloud微服务的世界！\"); return \"欢迎来到Spring Cloud微服务的世界！\"; &#125;&#125; 负载均衡肯定是同一个请求，但是被分到了不同的服务端口或者服务 那么我们现在将Service-A服务改变端口，启动两次模拟负载均衡的环境 我们现在重启项目，启动后查看注册中心： 现在我们重新运行：http://localhost:9999/hello 并且清空控制台，运行后你会发现，刚刚那就输出语句分别打印在项目的8888端口和8889端口，然后他们之间来回切换，这就是我们所谓的本地负载均衡。 三、总结 项目地址：https://github.com/xuhao008/Spring-Cloud Spring Cloud的环境搭建就到这里了，其实整体来说不难，整个帖子可能比较繁琐，都是一些入门级别的，我也是看了好多博主的帖子，最后自己才写出来的，希望可以给刚刚入门的人一些帮助。接下来我也会再写一篇使用spring cloud进行的增删改查一系列操作的dome，如果想了解更多可以看看。","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://xuhao008.github.io/tags/springcloud/"}]}],"categories":[],"tags":[{"name":"个人学习笔记","slug":"个人学习笔记","permalink":"http://xuhao008.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://xuhao008.github.io/tags/vue/"},{"name":"image","slug":"image","permalink":"http://xuhao008.github.io/tags/image/"},{"name":"java基础","slug":"java基础","permalink":"http://xuhao008.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"java","slug":"java","permalink":"http://xuhao008.github.io/tags/java/"},{"name":"springcloud","slug":"springcloud","permalink":"http://xuhao008.github.io/tags/springcloud/"},{"name":"docker","slug":"docker","permalink":"http://xuhao008.github.io/tags/docker/"},{"name":"单点登录","slug":"单点登录","permalink":"http://xuhao008.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://xuhao008.github.io/tags/elasticsearch/"},{"name":"高并发","slug":"高并发","permalink":"http://xuhao008.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"oracle","slug":"oracle","permalink":"http://xuhao008.github.io/tags/oracle/"},{"name":"JSTL","slug":"JSTL","permalink":"http://xuhao008.github.io/tags/JSTL/"}]}